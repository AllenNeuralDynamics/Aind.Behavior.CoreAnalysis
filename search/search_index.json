{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#contraqctor","title":"contraqctor","text":"<p>A library for managing data contracts and quality control in behavioral datasets.</p> <p>\u26a0\ufe0f Caution: This repository is currently under active development and is subject to frequent changes. Features and APIs may evolve without prior notice.</p>"},{"location":"#installing-and-upgrading","title":"Installing and Upgrading","text":"<p>If you choose to clone the repository, you can install the package by running the following command from the root directory of the repository:</p> <pre><code>pip install .\n</code></pre> <p>Otherwise, you can use pip:</p> <pre><code>pip install contraqctor\n</code></pre>"},{"location":"#getting-started-and-api-usage","title":"Getting started and API usage","text":"<p>The library provides two main functionalities: data contracts for standardized data loading and quality control tools for data validation.</p>"},{"location":"#creating-and-using-data-contracts","title":"Creating and Using Data Contracts","text":"<p>Data contracts provide a standard way to access and load data from various sources. Here's a simple example:</p> <pre><code>from pathlib import Path\nfrom contraqctor.contract import Dataset, DataStreamCollection\nfrom contraqctor.contract.csv import Csv\nfrom contraqctor.contract.text import Text\n\n# Define the dataset structure\ndataset_root = Path(\"path/to/dataset\")\nmy_dataset = Dataset(\n    name=\"my_dataset\",\n    version=\"1.0.0\",\n    description=\"Example dataset\",\n    data_streams=[\n        DataStreamCollection(\n            name=\"Behavior\",\n            description=\"Behavior data\",\n            data_streams=[\n                Csv(\n                    \"Position\",\n                    description=\"Animal position data\",\n                    reader_params=Csv.make_params(\n                        path=dataset_root / \"behavior/position.csv\",\n                    ),\n                ),\n                Text(\n                    name=\"Log\",\n                    description=\"Session log file\",\n                    reader_params=Text.make_params(\n                        path=dataset_root / \"behavior/session.log\",\n                    ),\n                ),\n            ],\n        ),\n    ],\n)\n\n# Load a specific stream\nposition_data = my_dataset[\"Behavior\"][\"Position\"].load().data\nprint(f\"Position data shape: {position_data.shape}\")\n\n# Load all streams and handle errors\nmy_dataset.load_all()\n</code></pre>"},{"location":"#quality-control-of-primary-data","title":"Quality Control of Primary Data","text":"<p>The QC module helps validate your data to ensure it meets specific requirements:</p> <pre><code>import contraqctor.qc as qc\n\n# Using the dataset created above\ndata_stream = my_dataset[\"Behavior\"][\"Position\"]\n\n# Create and run test suites\nrunner = qc.Runner()\n\n# Add test suites for different data types\nrunner.add_suite(qc.csv.CsvTestSuite(data_stream))\n\n# Or create your own custom test suite\nclass MyCustomTestSuite(qc.Suite):\n    def __init__(self, data_stream):\n        self.data_stream = data_stream\n\n    def test_has_expected_columns(self):\n        \"\"\"Check if data has required columns.\"\"\"\n        expected_cols = {\"timestamp\", \"x\", \"y\", \"speed\"}\n        if not expected_cols.issubset(self.data_stream.data.columns):\n            missing = expected_cols - set(self.data_stream.data.columns)\n            return self.fail_test(None, f\"Missing columns: {missing}\")\n        return self.pass_test(None, \"All required columns present\")\n\nrunner.add_suite(MyCustomTestSuite(data_stream))\n\n# Run all tests and display results\nresults = runner.run_all_with_progress()\n</code></pre> <p>For more detailed examples, please check the Examples folder.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Contributions to this repository are welcome! However, please ensure that your code adheres to the recommended DevOps practices below:</p>"},{"location":"#linting","title":"Linting","text":"<p>We use ruff as our primary linting tool.</p>"},{"location":"#testing","title":"Testing","text":"<p>Attempt to add tests when new features are added. To run the currently available tests, run <code>uv run pytest</code> from the root of the repository.</p>"},{"location":"#lock-files","title":"Lock files","text":"<p>We use uv to manage our lock files and therefore encourage everyone to use uv as a package manager as well.</p>"},{"location":"api/","title":"API Reference","text":"<p>The <code>contraqctor</code> package provides core primitives and utilities for behavioral data analysis.</p>"},{"location":"api/#modules","title":"Modules","text":"<ul> <li>Contract Module - Data stream abstractions and utilities for working with various file formats</li> <li>Quality Control Module - Framework for running quality control tests on datasets</li> </ul>"},{"location":"api/contract/base/","title":"contract.base","text":""},{"location":"api/contract/base/#contraqctor.contract.base.DataStream","title":"DataStream","text":"<pre><code>DataStream(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[TData, TReaderParams]</code></p> <p>Abstract base class for all data streams.</p> <p>Provides a generic interface for data reading operations with configurable parameters and hierarchical organization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the data stream.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the data stream.</p> <code>None</code> <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters for the data reader.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>_is_collection</code> <code>bool</code> <p>Class variable indicating if this is a collection of data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If name contains '::' characters which are reserved for path resolution.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStream.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase","title":"DataStreamCollectionBase","text":"<pre><code>DataStreamCollectionBase(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[List[TDataStream], TReaderParams]</code>, <code>Generic[TDataStream, TReaderParams]</code></p> <p>Base class for collections of data streams.</p> <p>Provides functionality for managing and accessing multiple child data streams.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the collection.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the collection.</p> <code>None</code> <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters for the reader.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    super().__init__(name=name, description=description, reader_params=reader_params, **kwargs)\n    self._hashmap: Dict[str, TDataStream] = {}\n    self._update_hashmap()\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollectionBase.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection","title":"DataStreamCollection","text":"<pre><code>DataStreamCollection(\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    description: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollectionBase[DataStream, UnsetParamsType]</code></p> <p>Collection of data streams with direct initialization.</p> <p>A specialized collection where child streams are passed directly instead of being created by a reader function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the collection.</p> required <code>data_streams</code> <code>List[DataStream]</code> <p>List of child data streams to include.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the collection.</p> <code>None</code> <p>Examples:</p> <pre><code>from contraqctor.contract import csv, text, DataStreamCollection\n\n# Create streams\ntext_stream = text.Text(\"readme\", reader_params=text.TextParams(path=\"README.md\"))\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n\n# Create the collection\ncollection = DataStreamCollection(\"project_files\", [text_stream, csv_stream])\n\n# Load and use\ncollection.load_all()\nreadme_content = collection[\"readme\"].data\n</code></pre> <p>Initializes a special DataStreamGroup where the data streams are passed directly, without a reader.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef __init__(\n    self,\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Initializes a special DataStreamGroup where the data streams are passed directly, without a reader.\"\"\"\n    super().__init__(\n        name=name,\n        description=description,\n        reader_params=_typing.UnsetParams,\n    )\n    self.bind_data_streams(data_streams)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.parameters","title":"parameters  <code>staticmethod</code>","text":"<pre><code>parameters(*args, **kwargs) -&gt; UnsetParamsType\n</code></pre> <p>Parameters function to return UnsetParams.</p> <p>Returns:</p> Name Type Description <code>UnsetParamsType</code> <code>UnsetParamsType</code> <p>Special unset parameters value.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@staticmethod\ndef parameters(*args, **kwargs) -&gt; _typing.UnsetParamsType:\n    \"\"\"Parameters function to return UnsetParams.\n\n    Returns:\n        UnsetParamsType: Special unset parameters value.\n    \"\"\"\n    return _typing.UnsetParams\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.read","title":"read","text":"<pre><code>read(*args, **kwargs) -&gt; List[DataStream]\n</code></pre> <p>Read data from the collection.</p> <p>Returns:</p> Type Description <code>List[DataStream]</code> <p>List[DataStream]: The pre-set data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef read(self, *args, **kwargs) -&gt; List[DataStream]:\n    \"\"\"Read data from the collection.\n\n    Returns:\n        List[DataStream]: The pre-set data streams.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet.\")\n    return self._data\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.bind_data_streams","title":"bind_data_streams","text":"<pre><code>bind_data_streams(data_streams: List[DataStream]) -&gt; Self\n</code></pre> <p>Bind a list of data streams to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_data_streams(self, data_streams: List[DataStream]) -&gt; Self:\n    \"\"\"Bind a list of data streams to the collection.\n\n    Args:\n        data_streams: List of data streams to include in the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If data streams have already been set.\n    \"\"\"\n    if self.has_data:\n        raise ValueError(\"Data streams are already set. Cannot bind again.\")\n    self._data = data_streams\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.add_stream","title":"add_stream","text":"<pre><code>add_stream(stream: DataStream) -&gt; Self\n</code></pre> <p>Add a new data stream to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>DataStream</code> <p>Data stream to add to the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a stream with the same name already exists.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import json, DataStreamCollection\n\n# Create an empty collection\ncollection = DataStreamCollection(\"api_data\", [])\n\n# Add streams\ncollection.add_stream(\n    json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n)\n\n# Load the data\ncollection.load_all()\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def add_stream(self, stream: DataStream) -&gt; Self:\n    \"\"\"Add a new data stream to the collection.\n\n    Args:\n        stream: Data stream to add to the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        KeyError: If a stream with the same name already exists.\n\n    Examples:\n        ```python\n        from contraqctor.contract import json, DataStreamCollection\n\n        # Create an empty collection\n        collection = DataStreamCollection(\"api_data\", [])\n\n        # Add streams\n        collection.add_stream(\n            json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        )\n\n        # Load the data\n        collection.load_all()\n        ```\n    \"\"\"\n    if not self.has_data:\n        self._data = [stream]\n        self._update_hashmap()\n        return self\n\n    if stream.name in self._hashmap:\n        raise KeyError(f\"Stream with name: '{stream.name}' already exists in data streams.\")\n\n    self._data.append(stream)\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.remove_stream","title":"remove_stream","text":"<pre><code>remove_stream(name: str) -&gt; None\n</code></pre> <p>Remove a data stream from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data stream to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> <code>KeyError</code> <p>If no stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def remove_stream(self, name: str) -&gt; None:\n    \"\"\"Remove a data stream from the collection.\n\n    Args:\n        name: Name of the data stream to remove.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n        KeyError: If no stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet. Cannot access data streams.\")\n\n    if name not in self._hashmap:\n        raise KeyError(f\"Data stream with name '{name}' not found in data streams.\")\n    self._data.remove(self._hashmap[name])\n    self._update_hashmap()\n    return\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.from_data_stream","title":"from_data_stream  <code>classmethod</code>","text":"<pre><code>from_data_stream(data_stream: DataStream) -&gt; Self\n</code></pre> <p>Create a DataStreamCollection from a DataStream object.</p> <p>Factory method to convert a single data stream or collection into a DataStreamCollection.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>DataStream</code> <p>Source data stream to convert.</p> required <p>Returns:</p> Name Type Description <code>DataStreamCollection</code> <code>Self</code> <p>New collection containing the source stream's data.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the source is not a DataStream.</p> <code>ValueError</code> <p>If the source has not been loaded yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@classmethod\ndef from_data_stream(cls, data_stream: DataStream) -&gt; Self:\n    \"\"\"Create a DataStreamCollection from a DataStream object.\n\n    Factory method to convert a single data stream or collection into a DataStreamCollection.\n\n    Args:\n        data_stream: Source data stream to convert.\n\n    Returns:\n        DataStreamCollection: New collection containing the source stream's data.\n\n    Raises:\n        TypeError: If the source is not a DataStream.\n        ValueError: If the source has not been loaded yet.\n    \"\"\"\n    if not isinstance(data_stream, DataStream):\n        raise TypeError(\"data_stream must be an instance of DataStream.\")\n    if not data_stream.has_data:\n        raise ValueError(\"DataStream has not been loaded yet. Cannot create DataStreamCollection.\")\n    data = data_stream.data if data_stream.is_collection else [data_stream.data]\n    return cls(name=data_stream.name, data_streams=data, description=data_stream.description)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.DataStreamCollection.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset","title":"Dataset","text":"<pre><code>Dataset(\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    version: str | Version = \"0.0.0\",\n    description: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollection</code></p> <p>A version-tracked collection of data streams.</p> <p>Extends DataStreamCollection by adding semantic versioning support.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the dataset.</p> required <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the dataset.</p> required <code>version</code> <code>str | Version</code> <p>Semantic version string or Version object. Defaults to \"0.0.0\".</p> <code>'0.0.0'</code> <code>description</code> <code>Optional[str]</code> <p>Optional description of the dataset.</p> <code>None</code> <p>Examples:</p> <pre><code>from contraqctor.contract import text, csv, Dataset\n\n# Create streams\ntext_stream = text.Text(\"notes\", reader_params=text.TextParams(path=\"notes.txt\"))\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n\n# Create a versioned dataset\ndataset = Dataset(\n    \"experiment_results\",\n    [text_stream, csv_stream],\n    version=\"1.2.3\"\n)\n\n# Load the dataset\ndataset.load_all(strict=True)\n\n# Access streams\ntxt = dataset[\"notes\"].data\ncsv_data = dataset[\"data\"].data\n\nprint(f\"Dataset version: {dataset.version}\")\n</code></pre> <p>Initializes a Dataset with a version and a list of data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef __init__(\n    self,\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    version: str | Version = \"0.0.0\",\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Initializes a Dataset with a version and a list of data streams.\"\"\"\n    super().__init__(\n        name=name,\n        data_streams=data_streams,\n        description=description,\n    )\n    self._version = self._parse_semver(version)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.version","title":"version  <code>property</code>","text":"<pre><code>version: Version\n</code></pre> <p>Get the semantic version of the dataset.</p> <p>Returns:</p> Name Type Description <code>Version</code> <code>Version</code> <p>Semantic version object.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.read","title":"read","text":"<pre><code>read(*args, **kwargs) -&gt; List[DataStream]\n</code></pre> <p>Read data from the collection.</p> <p>Returns:</p> Type Description <code>List[DataStream]</code> <p>List[DataStream]: The pre-set data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef read(self, *args, **kwargs) -&gt; List[DataStream]:\n    \"\"\"Read data from the collection.\n\n    Returns:\n        List[DataStream]: The pre-set data streams.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet.\")\n    return self._data\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.parameters","title":"parameters  <code>staticmethod</code>","text":"<pre><code>parameters(*args, **kwargs) -&gt; UnsetParamsType\n</code></pre> <p>Parameters function to return UnsetParams.</p> <p>Returns:</p> Name Type Description <code>UnsetParamsType</code> <code>UnsetParamsType</code> <p>Special unset parameters value.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@staticmethod\ndef parameters(*args, **kwargs) -&gt; _typing.UnsetParamsType:\n    \"\"\"Parameters function to return UnsetParams.\n\n    Returns:\n        UnsetParamsType: Special unset parameters value.\n    \"\"\"\n    return _typing.UnsetParams\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.bind_data_streams","title":"bind_data_streams","text":"<pre><code>bind_data_streams(data_streams: List[DataStream]) -&gt; Self\n</code></pre> <p>Bind a list of data streams to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_data_streams(self, data_streams: List[DataStream]) -&gt; Self:\n    \"\"\"Bind a list of data streams to the collection.\n\n    Args:\n        data_streams: List of data streams to include in the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If data streams have already been set.\n    \"\"\"\n    if self.has_data:\n        raise ValueError(\"Data streams are already set. Cannot bind again.\")\n    self._data = data_streams\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.add_stream","title":"add_stream","text":"<pre><code>add_stream(stream: DataStream) -&gt; Self\n</code></pre> <p>Add a new data stream to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>DataStream</code> <p>Data stream to add to the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a stream with the same name already exists.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import json, DataStreamCollection\n\n# Create an empty collection\ncollection = DataStreamCollection(\"api_data\", [])\n\n# Add streams\ncollection.add_stream(\n    json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n)\n\n# Load the data\ncollection.load_all()\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def add_stream(self, stream: DataStream) -&gt; Self:\n    \"\"\"Add a new data stream to the collection.\n\n    Args:\n        stream: Data stream to add to the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        KeyError: If a stream with the same name already exists.\n\n    Examples:\n        ```python\n        from contraqctor.contract import json, DataStreamCollection\n\n        # Create an empty collection\n        collection = DataStreamCollection(\"api_data\", [])\n\n        # Add streams\n        collection.add_stream(\n            json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        )\n\n        # Load the data\n        collection.load_all()\n        ```\n    \"\"\"\n    if not self.has_data:\n        self._data = [stream]\n        self._update_hashmap()\n        return self\n\n    if stream.name in self._hashmap:\n        raise KeyError(f\"Stream with name: '{stream.name}' already exists in data streams.\")\n\n    self._data.append(stream)\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.remove_stream","title":"remove_stream","text":"<pre><code>remove_stream(name: str) -&gt; None\n</code></pre> <p>Remove a data stream from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data stream to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> <code>KeyError</code> <p>If no stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def remove_stream(self, name: str) -&gt; None:\n    \"\"\"Remove a data stream from the collection.\n\n    Args:\n        name: Name of the data stream to remove.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n        KeyError: If no stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet. Cannot access data streams.\")\n\n    if name not in self._hashmap:\n        raise KeyError(f\"Data stream with name '{name}' not found in data streams.\")\n    self._data.remove(self._hashmap[name])\n    self._update_hashmap()\n    return\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.Dataset.from_data_stream","title":"from_data_stream  <code>classmethod</code>","text":"<pre><code>from_data_stream(data_stream: DataStream) -&gt; Self\n</code></pre> <p>Create a DataStreamCollection from a DataStream object.</p> <p>Factory method to convert a single data stream or collection into a DataStreamCollection.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>DataStream</code> <p>Source data stream to convert.</p> required <p>Returns:</p> Name Type Description <code>DataStreamCollection</code> <code>Self</code> <p>New collection containing the source stream's data.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the source is not a DataStream.</p> <code>ValueError</code> <p>If the source has not been loaded yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@classmethod\ndef from_data_stream(cls, data_stream: DataStream) -&gt; Self:\n    \"\"\"Create a DataStreamCollection from a DataStream object.\n\n    Factory method to convert a single data stream or collection into a DataStreamCollection.\n\n    Args:\n        data_stream: Source data stream to convert.\n\n    Returns:\n        DataStreamCollection: New collection containing the source stream's data.\n\n    Raises:\n        TypeError: If the source is not a DataStream.\n        ValueError: If the source has not been loaded yet.\n    \"\"\"\n    if not isinstance(data_stream, DataStream):\n        raise TypeError(\"data_stream must be an instance of DataStream.\")\n    if not data_stream.has_data:\n        raise ValueError(\"DataStream has not been loaded yet. Cannot create DataStreamCollection.\")\n    data = data_stream.data if data_stream.is_collection else [data_stream.data]\n    return cls(name=data_stream.name, data_streams=data, description=data_stream.description)\n</code></pre>"},{"location":"api/contract/base/#contraqctor.contract.base.FilePathBaseParam","title":"FilePathBaseParam  <code>dataclass</code>","text":"<pre><code>FilePathBaseParam(path: PathLike)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for file-based reader parameters.</p> <p>Base parameter class for readers that access files by path.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>PathLike</code> <p>Path to the file or directory to read from.</p>"},{"location":"api/contract/camera/","title":"contract.camera","text":""},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraData","title":"CameraData  <code>dataclass</code>","text":"<pre><code>CameraData(metadata: DataFrame, video_path: PathLike)\n</code></pre> <p>Container for camera data including metadata and video file reference.</p> <p>A frozen dataclass that holds both metadata about video recordings and a reference to the corresponding video file path.</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>DataFrame</code> <p>DataFrame containing camera frame metadata such as timestamps and frame indices.</p> <code>video_path</code> <code>PathLike</code> <p>Path to the video file associated with the metadata.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraData.has_video","title":"has_video  <code>property</code>","text":"<pre><code>has_video: bool\n</code></pre> <p>Check if the referenced video file exists and can be opened.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the video file exists and can be opened, False otherwise.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraData.video_frame_count","title":"video_frame_count  <code>property</code>","text":"<pre><code>video_frame_count: int\n</code></pre> <p>Get the total number of frames in the video.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of frames in the video file.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraData.video_frame_size","title":"video_frame_size  <code>property</code>","text":"<pre><code>video_frame_size: Tuple[int, int]\n</code></pre> <p>Get the dimensions of the video frames.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[int, int]</code> <p>A tuple containing the width and height of video frames in pixels.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraData.as_video_capture","title":"as_video_capture","text":"<pre><code>as_video_capture()\n</code></pre> <p>Context manager for handling video capture resources.</p> <p>Opens the video file as a cv2.VideoCapture and ensures it's properly released after use, even if an exception occurs.</p> <p>Yields:</p> Name Type Description <code>VideoCapture</code> <p>OpenCV VideoCapture object for the video file.</p> <p>Examples:</p> <pre><code>import cv2\n\n# Process video frames\nwith camera_data.as_video_capture() as cap:\n    ret, frame = cap.read()\n    if ret:\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        cv2.imwrite(\"first_frame.jpg\", gray)\n</code></pre> Source code in <code>src/contraqctor/contract/camera.py</code> <pre><code>@contextmanager\ndef as_video_capture(self):\n    \"\"\"Context manager for handling video capture resources.\n\n    Opens the video file as a cv2.VideoCapture and ensures it's properly released\n    after use, even if an exception occurs.\n\n    Yields:\n        VideoCapture: OpenCV VideoCapture object for the video file.\n\n    Examples:\n        ```python\n        import cv2\n\n        # Process video frames\n        with camera_data.as_video_capture() as cap:\n            ret, frame = cap.read()\n            if ret:\n                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n                cv2.imwrite(\"first_frame.jpg\", gray)\n        ```\n    \"\"\"\n    cap = VideoCapture(str(self.video_path))\n    try:\n        yield cap\n    finally:\n        cap.release()\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.CameraParams","title":"CameraParams  <code>dataclass</code>","text":"<pre><code>CameraParams(\n    path: PathLike,\n    metadata_name: str = \"metadata\",\n    video_name: str = \"video\",\n)\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code></p> <p>Parameters for camera data processing.</p> <p>Extends the base file path parameters with camera-specific options.</p> <p>Attributes:</p> Name Type Description <code>metadata_name</code> <code>str</code> <p>Base filename of the CSV file containing frame metadata.</p> <code>video_name</code> <code>str</code> <p>Base filename of the video file (without extension).</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera","title":"Camera","text":"<pre><code>Camera(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[CameraData, CameraParams]</code></p> <p>Camera data stream provider.</p> <p>A data stream implementation for reading camera metadata and video files, combining them into a single CameraData object.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.camera import Camera, CameraParams\n\n# Create and load a camera stream\nparams = CameraParams(path=\"recordings/experiment_1/camera1/\")\ncam_stream = Camera(\"front_view\", reader_params=params).load()\n\n# Access the data\ncamera_data = cam_stream.data\nmetadata_df = camera_data.metadata\n\n# Check video properties\nif camera_data.has_video:\n    print(f\"Dimensions: {camera_data.video_frame_size}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/camera/#contraqctor.contract.camera.Camera.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/core/","title":"contract","text":""},{"location":"api/contract/core/#contraqctor.contract.Dataset","title":"Dataset","text":"<pre><code>Dataset(\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    version: str | Version = \"0.0.0\",\n    description: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollection</code></p> <p>A version-tracked collection of data streams.</p> <p>Extends DataStreamCollection by adding semantic versioning support.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the dataset.</p> required <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the dataset.</p> required <code>version</code> <code>str | Version</code> <p>Semantic version string or Version object. Defaults to \"0.0.0\".</p> <code>'0.0.0'</code> <code>description</code> <code>Optional[str]</code> <p>Optional description of the dataset.</p> <code>None</code> <p>Examples:</p> <pre><code>from contraqctor.contract import text, csv, Dataset\n\n# Create streams\ntext_stream = text.Text(\"notes\", reader_params=text.TextParams(path=\"notes.txt\"))\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n\n# Create a versioned dataset\ndataset = Dataset(\n    \"experiment_results\",\n    [text_stream, csv_stream],\n    version=\"1.2.3\"\n)\n\n# Load the dataset\ndataset.load_all(strict=True)\n\n# Access streams\ntxt = dataset[\"notes\"].data\ncsv_data = dataset[\"data\"].data\n\nprint(f\"Dataset version: {dataset.version}\")\n</code></pre> <p>Initializes a Dataset with a version and a list of data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef __init__(\n    self,\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    version: str | Version = \"0.0.0\",\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Initializes a Dataset with a version and a list of data streams.\"\"\"\n    super().__init__(\n        name=name,\n        data_streams=data_streams,\n        description=description,\n    )\n    self._version = self._parse_semver(version)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.version","title":"version  <code>property</code>","text":"<pre><code>version: Version\n</code></pre> <p>Get the semantic version of the dataset.</p> <p>Returns:</p> Name Type Description <code>Version</code> <code>Version</code> <p>Semantic version object.</p>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.read","title":"read","text":"<pre><code>read(*args, **kwargs) -&gt; List[DataStream]\n</code></pre> <p>Read data from the collection.</p> <p>Returns:</p> Type Description <code>List[DataStream]</code> <p>List[DataStream]: The pre-set data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef read(self, *args, **kwargs) -&gt; List[DataStream]:\n    \"\"\"Read data from the collection.\n\n    Returns:\n        List[DataStream]: The pre-set data streams.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet.\")\n    return self._data\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.parameters","title":"parameters  <code>staticmethod</code>","text":"<pre><code>parameters(*args, **kwargs) -&gt; UnsetParamsType\n</code></pre> <p>Parameters function to return UnsetParams.</p> <p>Returns:</p> Name Type Description <code>UnsetParamsType</code> <code>UnsetParamsType</code> <p>Special unset parameters value.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@staticmethod\ndef parameters(*args, **kwargs) -&gt; _typing.UnsetParamsType:\n    \"\"\"Parameters function to return UnsetParams.\n\n    Returns:\n        UnsetParamsType: Special unset parameters value.\n    \"\"\"\n    return _typing.UnsetParams\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.bind_data_streams","title":"bind_data_streams","text":"<pre><code>bind_data_streams(data_streams: List[DataStream]) -&gt; Self\n</code></pre> <p>Bind a list of data streams to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_data_streams(self, data_streams: List[DataStream]) -&gt; Self:\n    \"\"\"Bind a list of data streams to the collection.\n\n    Args:\n        data_streams: List of data streams to include in the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If data streams have already been set.\n    \"\"\"\n    if self.has_data:\n        raise ValueError(\"Data streams are already set. Cannot bind again.\")\n    self._data = data_streams\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.add_stream","title":"add_stream","text":"<pre><code>add_stream(stream: DataStream) -&gt; Self\n</code></pre> <p>Add a new data stream to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>DataStream</code> <p>Data stream to add to the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a stream with the same name already exists.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import json, DataStreamCollection\n\n# Create an empty collection\ncollection = DataStreamCollection(\"api_data\", [])\n\n# Add streams\ncollection.add_stream(\n    json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n)\n\n# Load the data\ncollection.load_all()\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def add_stream(self, stream: DataStream) -&gt; Self:\n    \"\"\"Add a new data stream to the collection.\n\n    Args:\n        stream: Data stream to add to the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        KeyError: If a stream with the same name already exists.\n\n    Examples:\n        ```python\n        from contraqctor.contract import json, DataStreamCollection\n\n        # Create an empty collection\n        collection = DataStreamCollection(\"api_data\", [])\n\n        # Add streams\n        collection.add_stream(\n            json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        )\n\n        # Load the data\n        collection.load_all()\n        ```\n    \"\"\"\n    if not self.has_data:\n        self._data = [stream]\n        self._update_hashmap()\n        return self\n\n    if stream.name in self._hashmap:\n        raise KeyError(f\"Stream with name: '{stream.name}' already exists in data streams.\")\n\n    self._data.append(stream)\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.remove_stream","title":"remove_stream","text":"<pre><code>remove_stream(name: str) -&gt; None\n</code></pre> <p>Remove a data stream from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data stream to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> <code>KeyError</code> <p>If no stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def remove_stream(self, name: str) -&gt; None:\n    \"\"\"Remove a data stream from the collection.\n\n    Args:\n        name: Name of the data stream to remove.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n        KeyError: If no stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet. Cannot access data streams.\")\n\n    if name not in self._hashmap:\n        raise KeyError(f\"Data stream with name '{name}' not found in data streams.\")\n    self._data.remove(self._hashmap[name])\n    self._update_hashmap()\n    return\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.Dataset.from_data_stream","title":"from_data_stream  <code>classmethod</code>","text":"<pre><code>from_data_stream(data_stream: DataStream) -&gt; Self\n</code></pre> <p>Create a DataStreamCollection from a DataStream object.</p> <p>Factory method to convert a single data stream or collection into a DataStreamCollection.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>DataStream</code> <p>Source data stream to convert.</p> required <p>Returns:</p> Name Type Description <code>DataStreamCollection</code> <code>Self</code> <p>New collection containing the source stream's data.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the source is not a DataStream.</p> <code>ValueError</code> <p>If the source has not been loaded yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@classmethod\ndef from_data_stream(cls, data_stream: DataStream) -&gt; Self:\n    \"\"\"Create a DataStreamCollection from a DataStream object.\n\n    Factory method to convert a single data stream or collection into a DataStreamCollection.\n\n    Args:\n        data_stream: Source data stream to convert.\n\n    Returns:\n        DataStreamCollection: New collection containing the source stream's data.\n\n    Raises:\n        TypeError: If the source is not a DataStream.\n        ValueError: If the source has not been loaded yet.\n    \"\"\"\n    if not isinstance(data_stream, DataStream):\n        raise TypeError(\"data_stream must be an instance of DataStream.\")\n    if not data_stream.has_data:\n        raise ValueError(\"DataStream has not been loaded yet. Cannot create DataStreamCollection.\")\n    data = data_stream.data if data_stream.is_collection else [data_stream.data]\n    return cls(name=data_stream.name, data_streams=data, description=data_stream.description)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream","title":"DataStream","text":"<pre><code>DataStream(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[TData, TReaderParams]</code></p> <p>Abstract base class for all data streams.</p> <p>Provides a generic interface for data reading operations with configurable parameters and hierarchical organization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the data stream.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the data stream.</p> <code>None</code> <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters for the data reader.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>_is_collection</code> <code>bool</code> <p>Class variable indicating if this is a collection of data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If name contains '::' characters which are reserved for path resolution.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStream.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection","title":"DataStreamCollection","text":"<pre><code>DataStreamCollection(\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    description: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollectionBase[DataStream, UnsetParamsType]</code></p> <p>Collection of data streams with direct initialization.</p> <p>A specialized collection where child streams are passed directly instead of being created by a reader function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the collection.</p> required <code>data_streams</code> <code>List[DataStream]</code> <p>List of child data streams to include.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the collection.</p> <code>None</code> <p>Examples:</p> <pre><code>from contraqctor.contract import csv, text, DataStreamCollection\n\n# Create streams\ntext_stream = text.Text(\"readme\", reader_params=text.TextParams(path=\"README.md\"))\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n\n# Create the collection\ncollection = DataStreamCollection(\"project_files\", [text_stream, csv_stream])\n\n# Load and use\ncollection.load_all()\nreadme_content = collection[\"readme\"].data\n</code></pre> <p>Initializes a special DataStreamGroup where the data streams are passed directly, without a reader.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef __init__(\n    self,\n    name: str,\n    data_streams: List[DataStream],\n    *,\n    description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Initializes a special DataStreamGroup where the data streams are passed directly, without a reader.\"\"\"\n    super().__init__(\n        name=name,\n        description=description,\n        reader_params=_typing.UnsetParams,\n    )\n    self.bind_data_streams(data_streams)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.parameters","title":"parameters  <code>staticmethod</code>","text":"<pre><code>parameters(*args, **kwargs) -&gt; UnsetParamsType\n</code></pre> <p>Parameters function to return UnsetParams.</p> <p>Returns:</p> Name Type Description <code>UnsetParamsType</code> <code>UnsetParamsType</code> <p>Special unset parameters value.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@staticmethod\ndef parameters(*args, **kwargs) -&gt; _typing.UnsetParamsType:\n    \"\"\"Parameters function to return UnsetParams.\n\n    Returns:\n        UnsetParamsType: Special unset parameters value.\n    \"\"\"\n    return _typing.UnsetParams\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.read","title":"read","text":"<pre><code>read(*args, **kwargs) -&gt; List[DataStream]\n</code></pre> <p>Read data from the collection.</p> <p>Returns:</p> Type Description <code>List[DataStream]</code> <p>List[DataStream]: The pre-set data streams.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef read(self, *args, **kwargs) -&gt; List[DataStream]:\n    \"\"\"Read data from the collection.\n\n    Returns:\n        List[DataStream]: The pre-set data streams.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet.\")\n    return self._data\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.bind_data_streams","title":"bind_data_streams","text":"<pre><code>bind_data_streams(data_streams: List[DataStream]) -&gt; Self\n</code></pre> <p>Bind a list of data streams to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data_streams</code> <code>List[DataStream]</code> <p>List of data streams to include in the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_data_streams(self, data_streams: List[DataStream]) -&gt; Self:\n    \"\"\"Bind a list of data streams to the collection.\n\n    Args:\n        data_streams: List of data streams to include in the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If data streams have already been set.\n    \"\"\"\n    if self.has_data:\n        raise ValueError(\"Data streams are already set. Cannot bind again.\")\n    self._data = data_streams\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.add_stream","title":"add_stream","text":"<pre><code>add_stream(stream: DataStream) -&gt; Self\n</code></pre> <p>Add a new data stream to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>DataStream</code> <p>Data stream to add to the collection.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a stream with the same name already exists.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import json, DataStreamCollection\n\n# Create an empty collection\ncollection = DataStreamCollection(\"api_data\", [])\n\n# Add streams\ncollection.add_stream(\n    json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n)\n\n# Load the data\ncollection.load_all()\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def add_stream(self, stream: DataStream) -&gt; Self:\n    \"\"\"Add a new data stream to the collection.\n\n    Args:\n        stream: Data stream to add to the collection.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        KeyError: If a stream with the same name already exists.\n\n    Examples:\n        ```python\n        from contraqctor.contract import json, DataStreamCollection\n\n        # Create an empty collection\n        collection = DataStreamCollection(\"api_data\", [])\n\n        # Add streams\n        collection.add_stream(\n            json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        )\n\n        # Load the data\n        collection.load_all()\n        ```\n    \"\"\"\n    if not self.has_data:\n        self._data = [stream]\n        self._update_hashmap()\n        return self\n\n    if stream.name in self._hashmap:\n        raise KeyError(f\"Stream with name: '{stream.name}' already exists in data streams.\")\n\n    self._data.append(stream)\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.remove_stream","title":"remove_stream","text":"<pre><code>remove_stream(name: str) -&gt; None\n</code></pre> <p>Remove a data stream from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data stream to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If data streams have not been set yet.</p> <code>KeyError</code> <p>If no stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def remove_stream(self, name: str) -&gt; None:\n    \"\"\"Remove a data stream from the collection.\n\n    Args:\n        name: Name of the data stream to remove.\n\n    Raises:\n        ValueError: If data streams have not been set yet.\n        KeyError: If no stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"Data streams have not been read yet. Cannot access data streams.\")\n\n    if name not in self._hashmap:\n        raise KeyError(f\"Data stream with name '{name}' not found in data streams.\")\n    self._data.remove(self._hashmap[name])\n    self._update_hashmap()\n    return\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollection.from_data_stream","title":"from_data_stream  <code>classmethod</code>","text":"<pre><code>from_data_stream(data_stream: DataStream) -&gt; Self\n</code></pre> <p>Create a DataStreamCollection from a DataStream object.</p> <p>Factory method to convert a single data stream or collection into a DataStreamCollection.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>DataStream</code> <p>Source data stream to convert.</p> required <p>Returns:</p> Name Type Description <code>DataStreamCollection</code> <code>Self</code> <p>New collection containing the source stream's data.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the source is not a DataStream.</p> <code>ValueError</code> <p>If the source has not been loaded yet.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@classmethod\ndef from_data_stream(cls, data_stream: DataStream) -&gt; Self:\n    \"\"\"Create a DataStreamCollection from a DataStream object.\n\n    Factory method to convert a single data stream or collection into a DataStreamCollection.\n\n    Args:\n        data_stream: Source data stream to convert.\n\n    Returns:\n        DataStreamCollection: New collection containing the source stream's data.\n\n    Raises:\n        TypeError: If the source is not a DataStream.\n        ValueError: If the source has not been loaded yet.\n    \"\"\"\n    if not isinstance(data_stream, DataStream):\n        raise TypeError(\"data_stream must be an instance of DataStream.\")\n    if not data_stream.has_data:\n        raise ValueError(\"DataStream has not been loaded yet. Cannot create DataStreamCollection.\")\n    data = data_stream.data if data_stream.is_collection else [data_stream.data]\n    return cls(name=data_stream.name, data_streams=data, description=data_stream.description)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase","title":"DataStreamCollectionBase","text":"<pre><code>DataStreamCollectionBase(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[List[TDataStream], TReaderParams]</code>, <code>Generic[TDataStream, TReaderParams]</code></p> <p>Base class for collections of data streams.</p> <p>Provides functionality for managing and accessing multiple child data streams.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the collection.</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the collection.</p> <code>None</code> <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters for the reader.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    super().__init__(name=name, description=description, reader_params=reader_params, **kwargs)\n    self._hashmap: Dict[str, TDataStream] = {}\n    self._update_hashmap()\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.DataStreamCollectionBase.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/core/#contraqctor.contract.FilePathBaseParam","title":"FilePathBaseParam  <code>dataclass</code>","text":"<pre><code>FilePathBaseParam(path: PathLike)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for file-based reader parameters.</p> <p>Base parameter class for readers that access files by path.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>PathLike</code> <p>Path to the file or directory to read from.</p>"},{"location":"api/contract/core/#contraqctor.contract.print_data_stream_tree","title":"print_data_stream_tree","text":"<pre><code>print_data_stream_tree(\n    node: DataStream,\n    prefix: str = \"\",\n    is_last: bool = True,\n    parents: list[bool] = [],\n    show_params: bool = False,\n    show_type: bool = False,\n    show_missing_indicator: bool = True,\n) -&gt; str\n</code></pre> <p>Generates a tree representation of a data stream hierarchy.</p> <p>Creates a formatted string displaying the hierarchical structure of a data stream and its children as a tree with branch indicators and icons.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DataStream</code> <p>The data stream node to start printing from.</p> required <code>prefix</code> <code>str</code> <p>Prefix string to prepend to each line, used for indentation.</p> <code>''</code> <code>is_last</code> <code>bool</code> <p>Whether this node is the last child of its parent.</p> <code>True</code> <code>parents</code> <code>list[bool]</code> <p>List tracking whether each ancestor was a last child, used for drawing branches.</p> <code>[]</code> <code>show_params</code> <code>bool</code> <p>Whether to render parameters of the datastream.</p> <code>False</code> <code>show_type</code> <code>bool</code> <p>Whether to render the class name of the datastream.</p> <code>False</code> <code>show_missing_indicator</code> <code>bool</code> <p>Whether to render the missing data indicator.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string representing the data stream tree.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import Dataset, csv, json\nfrom contraqctor.contract.utils import print_data_stream_tree\n\n# Create a dataset with streams\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\njson_stream = json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\ndataset = Dataset(\"experiment\", [csv_stream, json_stream], version=\"1.0.0\")\n\n# Print the tree\ntree = print_data_stream_tree(dataset)\nprint(tree)\n# Output:\n# \ud83d\udcc2 experiment\n# \u251c\u2500\u2500 \ud83d\udcc4 data\n# \u2514\u2500\u2500 \ud83d\udcc4 config\n</code></pre> Source code in <code>src/contraqctor/contract/utils.py</code> <pre><code>def print_data_stream_tree(\n    node: DataStream,\n    prefix: str = \"\",\n    is_last: bool = True,\n    parents: list[bool] = [],\n    show_params: bool = False,\n    show_type: bool = False,\n    show_missing_indicator: bool = True,\n) -&gt; str:\n    \"\"\"Generates a tree representation of a data stream hierarchy.\n\n    Creates a formatted string displaying the hierarchical structure of a data stream\n    and its children as a tree with branch indicators and icons.\n\n    Args:\n        node: The data stream node to start printing from.\n        prefix: Prefix string to prepend to each line, used for indentation.\n        is_last: Whether this node is the last child of its parent.\n        parents: List tracking whether each ancestor was a last child, used for drawing branches.\n        show_params: Whether to render parameters of the datastream.\n        show_type: Whether to render the class name of the datastream.\n        show_missing_indicator: Whether to render the missing data indicator.\n\n    Returns:\n        str: A formatted string representing the data stream tree.\n\n    Examples:\n        ```python\n        from contraqctor.contract import Dataset, csv, json\n        from contraqctor.contract.utils import print_data_stream_tree\n\n        # Create a dataset with streams\n        csv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n        json_stream = json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        dataset = Dataset(\"experiment\", [csv_stream, json_stream], version=\"1.0.0\")\n\n        # Print the tree\n        tree = print_data_stream_tree(dataset)\n        print(tree)\n        # Output:\n        # \ud83d\udcc2 experiment\n        # \u251c\u2500\u2500 \ud83d\udcc4 data\n        # \u2514\u2500\u2500 \ud83d\udcc4 config\n        ```\n    \"\"\"\n    icon_map = {\n        False: \"\ud83d\udcc4\",\n        True: \"\ud83d\udcc2\",\n        None: \"\u2753\",\n    }\n\n    node_icon = icon_map[node.is_collection]\n    if not node.has_data and show_missing_indicator:\n        node_icon += f\"{icon_map[None]}\"\n\n    line_prefix = \"\"\n    for parent_is_last in parents[:-1]:\n        line_prefix += \"    \" if parent_is_last else \"\u2502   \"\n\n    if parents:\n        branch = \"\u2514\u2500\u2500 \" if is_last else \"\u251c\u2500\u2500 \"\n        line_prefix += branch\n\n    # Build node label with name, type, and parameters\n    node_label = node.name\n\n    if show_type:\n        node_label += f\" [{node.__class__.__name__}]\"\n\n    if show_params and hasattr(node, \"reader_params\") and node.reader_params:\n        params_str = str(node.reader_params)\n        node_label += f\" ({params_str})\"\n\n    tree_representation = f\"{line_prefix}{node_icon} {node_label}\\n\"\n\n    if node.is_collection and node.has_data:\n        for i, child in enumerate(node.data):\n            child_is_last = i == len(node.data) - 1\n            tree_representation += print_data_stream_tree(\n                child,\n                prefix=\"\",\n                is_last=child_is_last,\n                parents=parents + [is_last],\n                show_params=show_params,\n                show_type=show_type,\n                show_missing_indicator=show_missing_indicator,\n            )\n\n    return tree_representation\n</code></pre>"},{"location":"api/contract/csv/","title":"contract.csv","text":""},{"location":"api/contract/csv/#contraqctor.contract.csv.CsvParams","title":"CsvParams  <code>dataclass</code>","text":"<pre><code>CsvParams(\n    path: PathLike,\n    delimiter: Optional[str] = None,\n    strict_header: bool = True,\n    index: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code></p> <p>Parameters for CSV file processing.</p> <p>Extends the base file path parameters with CSV-specific options.</p> <p>Attributes:</p> Name Type Description <code>delimiter</code> <code>Optional[str]</code> <p>Custom delimiter character for CSV parsing. If None, the default comma delimiter is used.</p> <code>strict_header</code> <code>bool</code> <p>If True, treats the first row as a header. Otherwise, no header is assumed.</p> <code>index</code> <code>Optional[str]</code> <p>Column name to set as the DataFrame index. If None, default numeric indices are used.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv","title":"Csv","text":"<pre><code>Csv(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[DataFrame, CsvParams]</code></p> <p>CSV file data stream provider.</p> <p>A data stream implementation for reading CSV files into pandas DataFrames with configurable parameters for delimiter, header handling, and indexing.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.csv import Csv, CsvParams\n\n# Create and load a CSV stream\nparams = CsvParams(path=\"data/european_data.csv\", delimiter=\";\")\ncsv_stream = Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the DataFrame\ndf = csv_stream.data\nfiltered = df[df[\"temperature\"] &gt; 25]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/csv/#contraqctor.contract.csv.Csv.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/harp/","title":"contract.harp","text":""},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister","title":"HarpRegister","text":"<pre><code>HarpRegister(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[DataFrame, HarpRegisterParams]</code></p> <p>Harp device register data stream provider.</p> <p>A data stream implementation for reading Harp device register data using the Harp Python library.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[HarpRegisterParams] = None,\n) -&gt; DataFrame\n</code></pre> <p>Read register data from Harp binary files.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[HarpRegisterParams]</code> <p>Parameters for register reading configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing the register data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/harp.py</code> <pre><code>@override\ndef read(self, reader_params: Optional[HarpRegisterParams] = None) -&gt; pd.DataFrame:\n    \"\"\"Read register data from Harp binary files.\n\n    Args:\n        reader_params: Parameters for register reading configuration.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the register data.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params.base_path, epoch=reader_params.epoch, keep_type=reader_params.keep_type)\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.from_register_reader","title":"from_register_reader  <code>classmethod</code>","text":"<pre><code>from_register_reader(\n    name: str,\n    reg_reader: RegisterReader,\n    params: HarpRegisterParams = _DEFAULT_HARP_READER_PARAMS,\n) -&gt; Self\n</code></pre> <p>Create a HarpRegister data stream from a RegisterReader.</p> <p>Factory method to create a HarpRegister instance from an existing Harp RegisterReader object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the register data stream.</p> required <code>reg_reader</code> <code>RegisterReader</code> <p>Harp RegisterReader object.</p> required <code>params</code> <code>HarpRegisterParams</code> <p>Parameters for register reading configuration.</p> <code>_DEFAULT_HARP_READER_PARAMS</code> <p>Returns:</p> Name Type Description <code>HarpRegister</code> <code>Self</code> <p>Newly created HarpRegister data stream.</p> Source code in <code>src/contraqctor/contract/harp.py</code> <pre><code>@classmethod\ndef from_register_reader(\n    cls,\n    name: str,\n    reg_reader: harp.reader.RegisterReader,\n    params: HarpRegisterParams = _DEFAULT_HARP_READER_PARAMS,\n) -&gt; Self:\n    \"\"\"Create a HarpRegister data stream from a RegisterReader.\n\n    Factory method to create a HarpRegister instance from an existing\n    Harp RegisterReader object.\n\n    Args:\n        name: Name for the register data stream.\n        reg_reader: Harp RegisterReader object.\n        params: Parameters for register reading configuration.\n\n    Returns:\n        HarpRegister: Newly created HarpRegister data stream.\n    \"\"\"\n    c = cls(\n        name=name,\n        description=reg_reader.register.description,\n    )\n    c.bind_reader_params(params)\n    c._reader = reg_reader.read\n    c.make_params = cls.make_params\n    return c\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpRegister.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.DeviceYmlByWhoAmI","title":"DeviceYmlByWhoAmI","text":"<p>               Bases: <code>_DeviceYmlSource</code></p> <p>Device YAML source that finds the file using WhoAmI value.</p> <p>Specifies that the device YAML should be obtained by looking up a device by its WhoAmI identifier.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Literal['whoami']</code> <p>Fixed as \"whoami\".</p> <code>who_am_i</code> <code>Annotated[int, Field(ge=0, le=9999, description='WhoAmI value')]</code> <p>The WhoAmI value of the device (0-9999).</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.DeviceYmlByFile","title":"DeviceYmlByFile","text":"<p>               Bases: <code>_DeviceYmlSource</code></p> <p>Device YAML source that specifies a file path.</p> <p>Specifies that the device YAML should be loaded from a local file path.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Literal['file']</code> <p>Fixed as \"file\".</p> <code>path</code> <code>Optional[PathLike | str]</code> <p>Optional path to the device YAML file. If None, assumes \"device.yml\" in the data directory.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.DeviceYmlByUrl","title":"DeviceYmlByUrl","text":"<p>               Bases: <code>_DeviceYmlSource</code></p> <p>Device YAML source that fetches from a URL.</p> <p>Specifies that the device YAML should be downloaded from a URL.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Literal['http']</code> <p>Fixed as \"http\".</p> <code>url</code> <code>AnyHttpUrl</code> <p>HTTP URL to download the device YAML file from.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.DeviceYmlByRegister0","title":"DeviceYmlByRegister0","text":"<p>               Bases: <code>_DeviceYmlSource</code></p> <p>Device YAML source that infers from register 0 file.</p> <p>Specifies that the device YAML should be determined by finding and reading the WhoAmI value from register 0 files.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Literal['register0']</code> <p>Fixed as \"register0\".</p> <code>register0_glob_pattern</code> <code>List[str]</code> <p>List of glob patterns to locate register 0 files.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDeviceParams","title":"HarpDeviceParams  <code>dataclass</code>","text":"<pre><code>HarpDeviceParams(path: PathLike)\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code></p> <p>Parameters for Harp device data reading.</p> <p>Defines parameters for locating and reading Harp device data.</p> <p>Attributes:</p> Name Type Description <code>device_yml_hint</code> <code>DeviceYmlSource</code> <p>Source for the device YAML configuration file.</p> <code>include_common_registers</code> <code>bool</code> <p>Whether to include common registers. Defaults to True.</p> <code>keep_type</code> <code>bool</code> <p>Whether to preserve type information. Defaults to True.</p> <code>epoch</code> <code>Optional[datetime]</code> <p>Reference datetime for timestamp calculations. If provided, timestamps are converted to datetime.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice","title":"HarpDevice","text":"<pre><code>HarpDevice(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollectionBase[HarpRegister, HarpDeviceParams]</code></p> <p>Harp device data stream collection provider.</p> <p>A data stream collection for accessing all registers of a Harp device.</p> <p>Parameters:</p> Name Type Description Default <code>DataStreamCollectionBase</code> <p>Base class for data stream collection providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.harp import HarpDevice, HarpDeviceParams, DeviceYmlByWhoAmI\n\n# Create and load a device stream\nparams = HarpDeviceParams(\n    path=\"behavior.harp\",\n    device_yml_hint=DeviceYmlByWhoAmI(who_am_i=1216)\n)\n\nbehavior = HarpDevice(\"behavior\", reader_params=params).load()\n\n# Access registers\ndigital_input = behavior[\"DigitalInputState\"].data\nadc = behavior[\"AnalogData\"].data\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    super().__init__(name=name, description=description, reader_params=reader_params, **kwargs)\n    self._hashmap: Dict[str, TDataStream] = {}\n    self._update_hashmap()\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.device_reader","title":"device_reader  <code>property</code>","text":"<pre><code>device_reader: DeviceReader\n</code></pre> <p>Get the underlying Harp device reader.</p> <p>Returns:</p> Type Description <code>DeviceReader</code> <p>harp.reader.DeviceReader: Harp device reader for accessing raw device functionality.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device reader has not been initialized.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.HarpDevice.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.fetch_yml_from_who_am_i","title":"fetch_yml_from_who_am_i","text":"<pre><code>fetch_yml_from_who_am_i(\n    who_am_i: int, release: str = \"main\"\n) -&gt; BytesIO\n</code></pre> <p>Fetch a device YAML file based on its WhoAmI identifier.</p> <p>Looks up the device in the WhoAmI registry and downloads its YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>who_am_i</code> <code>int</code> <p>WhoAmI identifier of the device.</p> required <code>release</code> <code>str</code> <p>Git branch or tag to use for fetching the YAML file.</p> <code>'main'</code> <p>Returns:</p> Type Description <code>BytesIO</code> <p>io.BytesIO: Memory buffer containing the device YAML content.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the WhoAmI identifier is not found in the registry.</p> <code>ValueError</code> <p>If required repository information is missing or YAML file cannot be found.</p> Source code in <code>src/contraqctor/contract/harp.py</code> <pre><code>def fetch_yml_from_who_am_i(who_am_i: int, release: str = \"main\") -&gt; io.BytesIO:\n    \"\"\"Fetch a device YAML file based on its WhoAmI identifier.\n\n    Looks up the device in the WhoAmI registry and downloads its YAML file.\n\n    Args:\n        who_am_i: WhoAmI identifier of the device.\n        release: Git branch or tag to use for fetching the YAML file.\n\n    Returns:\n        io.BytesIO: Memory buffer containing the device YAML content.\n\n    Raises:\n        KeyError: If the WhoAmI identifier is not found in the registry.\n        ValueError: If required repository information is missing or YAML file cannot be found.\n    \"\"\"\n    try:\n        device = fetch_who_am_i_list()[who_am_i]\n    except KeyError as e:\n        raise KeyError(f\"WhoAmI {who_am_i} not found in whoami.yml\") from e\n\n    repository_url = device.get(\"repositoryUrl\", None)\n\n    if repository_url is None:\n        raise ValueError(\"Device's repositoryUrl not found in whoami.yml\")\n\n    _repo_hint_paths = [\n        \"{repository_url}/{release}/device.yml\",\n        \"{repository_url}/{release}/software/bonsai/device.yml\",\n    ]\n\n    yml = None\n    for hint in _repo_hint_paths:\n        url = hint.format(repository_url=repository_url, release=release)\n        if \"github.com\" in url:\n            url = url.replace(\"github.com\", \"raw.githubusercontent.com\")\n        response = requests.get(url, allow_redirects=True, timeout=5)\n        if response.status_code == 200:\n            yml = io.BytesIO(response.content)\n            return yml\n\n    raise ValueError(\"device.yml not found in any repository\")\n</code></pre>"},{"location":"api/contract/harp/#contraqctor.contract.harp.fetch_who_am_i_list","title":"fetch_who_am_i_list  <code>cached</code>","text":"<pre><code>fetch_who_am_i_list(\n    url: str = \"https://raw.githubusercontent.com/harp-tech/whoami/main/whoami.yml\",\n) -&gt; Dict[int, Any]\n</code></pre> <p>Fetch and parse the Harp WhoAmI registry.</p> <p>Downloads and parses the WhoAmI registry YAML file from GitHub. Results are cached for efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the WhoAmI registry YAML file.</p> <code>'https://raw.githubusercontent.com/harp-tech/whoami/main/whoami.yml'</code> <p>Returns:</p> Type Description <code>Dict[int, Any]</code> <p>Dict[int, Any]: Dictionary mapping WhoAmI identifiers to device information.</p> Source code in <code>src/contraqctor/contract/harp.py</code> <pre><code>@cache\ndef fetch_who_am_i_list(\n    url: str = \"https://raw.githubusercontent.com/harp-tech/whoami/main/whoami.yml\",\n) -&gt; Dict[int, Any]:\n    \"\"\"Fetch and parse the Harp WhoAmI registry.\n\n    Downloads and parses the WhoAmI registry YAML file from GitHub.\n    Results are cached for efficiency.\n\n    Args:\n        url: URL to the WhoAmI registry YAML file.\n\n    Returns:\n        Dict[int, Any]: Dictionary mapping WhoAmI identifiers to device information.\n    \"\"\"\n    response = requests.get(url, allow_redirects=True, timeout=5)\n    content = response.content.decode(\"utf-8\")\n    content = yaml.safe_load(content)\n    devices = content[\"devices\"]\n    return devices\n</code></pre>"},{"location":"api/contract/json/","title":"contract.json","text":""},{"location":"api/contract/json/#contraqctor.contract.json.JsonParams","title":"JsonParams  <code>dataclass</code>","text":"<pre><code>JsonParams(path: PathLike, encoding: str = 'UTF-8')\n</code></pre> <p>Parameters for JSON file processing.</p> <p>Defines parameters for reading JSON files with specified encoding.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>PathLike</code> <p>Path to the JSON file.</p> <code>encoding</code> <code>str</code> <p>Character encoding for the JSON file. Defaults to UTF-8.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json","title":"Json","text":"<pre><code>Json(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[dict[str, str], JsonParams]</code></p> <p>JSON file data stream provider.</p> <p>A data stream implementation for reading single JSON objects from files.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.json import Json, JsonParams\n\n# Create and load a JSON stream\nconfig_stream = Json(\n    \"config\",\n    reader_params=JsonParams(path=\"config/settings.json\")\n)\nconfig_stream.load()\n\n# Access the data\nconfig = config_stream.data\napi_key = config.get(\"api_key\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.Json.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson","title":"MultiLineJson","text":"<pre><code>MultiLineJson(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[list[dict[str, str]], JsonParams]</code></p> <p>Multi-line JSON file data stream provider.</p> <p>A data stream implementation for reading JSON files where each line contains a separate JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.json import MultiLineJson, JsonParams\n\n# Create and load a multi-line JSON stream\nlogs_stream = MultiLineJson(\n    \"server_logs\",\n    reader_params=JsonParams(path=\"logs/server_logs.jsonl\")\n)\nlogs_stream.load()\n\n# Process log entries\nfor entry in logs_stream.data:\n    if entry.get(\"level\") == \"ERROR\":\n        print(f\"Error: {entry.get('message')}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.MultiLineJson.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModelParams","title":"PydanticModelParams  <code>dataclass</code>","text":"<pre><code>PydanticModelParams(\n    path: PathLike,\n    model: Type[_TModel],\n    encoding: str = \"UTF-8\",\n)\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code>, <code>Generic[_TModel]</code></p> <p>Parameters for Pydantic model-based JSON file processing.</p> <p>Extends the base file path parameters with Pydantic model specification for parsing JSON into typed objects.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[_TModel]</code> <p>Pydantic model class to use for parsing JSON data.</p> <code>encoding</code> <code>str</code> <p>Character encoding for the JSON file. Defaults to UTF-8.</p> <p>Examples:</p> <pre><code>from pydantic import BaseModel\nfrom contraqctor.contract.json import PydanticModelParams\n\nclass User(BaseModel):\n    user_id: str\n    name: str\n    active: bool = True\n\nparams = PydanticModelParams(path=\"users/profile.json\", model=User)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel","title":"PydanticModel","text":"<pre><code>PydanticModel(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[_TModel, PydanticModelParams[_TModel]]</code></p> <p>Pydantic model-based JSON data stream provider.</p> <p>A data stream implementation for reading JSON files as Pydantic model instances.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from pydantic import BaseModel\nfrom contraqctor.contract.json import PydanticModel, PydanticModelParams\n\nclass ServerConfig(BaseModel):\n    host: str\n    port: int\n    debug: bool = False\n\nparams = PydanticModelParams(path=\"config/server.json\", model=ServerConfig)\n\nconfig_stream = PydanticModel(\"server_config\", reader_params=params).load()\nserver_config = config_stream.data\nprint(f\"Server: {server_config.host}:{server_config.port}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.PydanticModel.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModelParams","title":"ManyPydanticModelParams  <code>dataclass</code>","text":"<pre><code>ManyPydanticModelParams(\n    path: PathLike,\n    model: Type[_TModel],\n    encoding: str = \"UTF-8\",\n    index: Optional[str] = None,\n    column_names: Optional[dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code>, <code>Generic[_TModel]</code></p> <p>Parameters for loading multiple Pydantic models from a file.</p> <p>Extends the base file path parameters with Pydantic model specification and options for converting to a DataFrame.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[_TModel]</code> <p>Pydantic model class to use for parsing JSON data.</p> <code>encoding</code> <code>str</code> <p>Character encoding for the JSON file. Defaults to UTF-8.</p> <code>index</code> <code>Optional[str]</code> <p>Optional column name to set as the DataFrame index.</p> <code>column_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary mapping original column names to new names.</p> <p>Examples:</p> <p>Defining parameters to load multiple models:</p> <pre><code>from pydantic import BaseModel\nfrom contraqctor.contract.json import ManyPydanticModelParams\n\n# Define a Pydantic model for log entries\nclass LogEntry(BaseModel):\n    timestamp: str\n    level: str\n    message: str\n\n# Create parameters for loading log entries\nparams = ManyPydanticModelParams(\n    path=\"logs/server_logs.json\",\n    model=LogEntry,\n    index=\"timestamp\",\n    column_names={\"level\": \"log_level\", \"message\": \"log_message\"}\n)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel","title":"ManyPydanticModel","text":"<pre><code>ManyPydanticModel(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[DataFrame, ManyPydanticModelParams[_TModel]]</code></p> <p>Multi-model JSON data stream provider.</p> <p>A data stream implementation for reading multiple JSON objects from a file, parsing them as Pydantic models, and returning them as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <p>Loading server logs into a DataFrame:</p> <pre><code>from contraqctor.contract.json import ManyPydanticModel, ManyPydanticModelParams\n\n# Create and load the data stream\nlogs_stream = ManyPydanticModel(\n    \"server_logs_df\",\n    reader_params=params\n)\nlogs_stream.load()\n\n# Access the logs as a DataFrame\nlogs_df = logs_stream.data\n\n# Analyze the logs\nerror_logs = logs_df[logs_df[\"log_level\"] == \"ERROR\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.ManyPydanticModel.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEventsParams","title":"SoftwareEventsParams  <code>dataclass</code>","text":"<pre><code>SoftwareEventsParams(\n    path: PathLike,\n    model: Type[_TModel],\n    encoding: str = \"UTF-8\",\n    index: Optional[str] = None,\n    column_names: Optional[dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>ManyPydanticModelParams</code></p> <p>Parameters for software events file processing.</p> <p>A specialized version of ManyPydanticModelParams that defaults to using the SoftwareEvent model from aind_behavior_services.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[SoftwareEvent]</code> <p>Set to SoftwareEvent model and not modifiable after initialization.</p> <code>encoding</code> <code>str</code> <p>Character encoding for the JSON file. Defaults to UTF-8.</p> <code>index</code> <code>Optional[str]</code> <p>Optional column name to set as the DataFrame index.</p> <code>column_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary mapping original column names to new names.</p> <p>Examples:</p> <p>Defining parameters for loading software events:</p> <pre><code>from contraqctor.contract.json import SoftwareEventsParams\n\n# Create parameters for software events\nparams = SoftwareEventsParams(\n    path=\"events/software_events.json\",\n    index=\"event_id\",\n    column_names={\"timestamp\": \"event_time\"}\n)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents","title":"SoftwareEvents","text":"<pre><code>SoftwareEvents(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>ManyPydanticModel[SoftwareEvent]</code></p> <p>Software events data stream provider.</p> <p>A specialized data stream for reading software event logs from JSON files using the SoftwareEvent model from aind_behavior_services.</p> <p>Parameters:</p> Name Type Description Default <code>ManyPydanticModel</code> <p>Base class for multi-model data stream providers.</p> required <p>Examples:</p> <p>Analyzing software events data:</p> <pre><code>from contraqctor.contract.json import SoftwareEvents, SoftwareEventsParams\n\n# Create parameters for software events\nparams = SoftwareEventsParams(\n    path=\"events/software_events.json\",\n    index=\"event_id\"\n)\n\n# Create and load the software events stream\nevents_stream = SoftwareEvents(\n    \"software_events\",\n    reader_params=params\n)\nevents_stream.load()\n\n# Access the events data\nevents_df = events_stream.data\n\n# Perform analysis, e.g., count events by type\nevent_counts = events_df[\"event_type\"].value_counts()\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/json/#contraqctor.contract.json.SoftwareEvents.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/mux/","title":"contract.mux","text":""},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPathsParams","title":"MapFromPathsParams  <code>dataclass</code>","text":"<pre><code>MapFromPathsParams(\n    paths: List[PathLike],\n    include_glob_pattern: List[str],\n    inner_data_stream: Type[_TDataStream],\n    inner_param_factory: Callable[[str], TReaderParams],\n    as_collection: bool = True,\n    exclude_glob_pattern: List[str] = list(),\n    inner_descriptions: dict[str, Optional[str]] = dict(),\n)\n</code></pre> <p>               Bases: <code>Generic[_TDataStream]</code></p> <p>Parameters for creating multiple data streams from file paths.</p> <p>Defines parameters for locating files and creating data streams for each one.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>List[PathLike]</code> <p>List of directory paths to search for files.</p> <code>include_glob_pattern</code> <code>List[str]</code> <p>List of glob patterns to match files to include.</p> <code>inner_data_stream</code> <code>Type[_TDataStream]</code> <p>Type of DataStream to create for each matched file.</p> <code>inner_param_factory</code> <code>Callable[[str], TReaderParams]</code> <p>Function that creates reader params from file paths.</p> <code>as_collection</code> <code>bool</code> <p>Whether to return results as a collection. Defaults to True.</p> <code>exclude_glob_pattern</code> <code>List[str]</code> <p>List of glob patterns for files to exclude.</p> <code>inner_descriptions</code> <code>dict[str, Optional[str]]</code> <p>Dictionary mapping file stems to descriptions for streams.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths","title":"MapFromPaths","text":"<pre><code>MapFromPaths(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStreamCollectionBase[_TDataStream, MapFromPathsParams]</code></p> <p>File path mapper data stream provider.</p> <p>A data stream implementation for creating multiple child data streams by searching for files matching glob patterns and creating a stream for each.</p> <p>Parameters:</p> Name Type Description Default <code>DataStreamCollectionBase</code> <p>Base class for data stream collection providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract import mux, text\n\n# Define a factory function for TextParams\ndef create_text_params(file_path):\n    return text.TextParams(path=file_path)\n\n# Create and load a text file collection\nparams = mux.MapFromPathsParams(\n    paths=[\"documents/\"],\n    include_glob_pattern=[\"*.txt\"],\n    inner_data_stream=text.Text,\n    inner_param_factory=create_text_params\n)\n\ndocs = mux.MapFromPaths(\"documents\", reader_params=params).load()\nreadme = docs[\"readme\"].data\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    super().__init__(name=name, description=description, reader_params=reader_params, **kwargs)\n    self._hashmap: Dict[str, TDataStream] = {}\n    self._update_hashmap()\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.at","title":"at","text":"<pre><code>at(name: str) -&gt; TDataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>TDataStream</code> <code>TDataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p> <code>KeyError</code> <p>If no child stream with the given name exists.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef at(self, name: str) -&gt; TDataStream:\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        TDataStream: The child data stream with the given name.\n\n    Raises:\n        ValueError: If data has not been loaded yet.\n        KeyError: If no child stream with the given name exists.\n    \"\"\"\n    if not self.has_data:\n        raise ValueError(\"data streams have not been read yet. Cannot access data streams.\")\n    if name in self._hashmap:\n        return self._hashmap[name]\n    else:\n        raise KeyError(f\"Stream with name: '{name}' not found in data streams.\")\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load data for this collection.</p> <p>Overrides the base method to add validation that loaded data is a list of DataStreams.</p> <p>Returns:</p> Name Type Description <code>Self</code> <p>The collection instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If loaded data is not a list of DataStreams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>@override\ndef load(self):\n    \"\"\"Load data for this collection.\n\n    Overrides the base method to add validation that loaded data is a list of DataStreams.\n\n    Returns:\n        Self: The collection instance for method chaining.\n\n    Raises:\n        ValueError: If loaded data is not a list of DataStreams.\n    \"\"\"\n    super().load()\n    if not isinstance(self._data, list):\n        self._data = _typing.UnsetData\n        raise ValueError(\"Data must be a list of DataStreams.\")\n    self._update_hashmap()\n    return self\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/mux/#contraqctor.contract.mux.MapFromPaths.iter_all","title":"iter_all","text":"<pre><code>iter_all() -&gt; Generator[DataStream, None, None]\n</code></pre> <p>Iterator for all child data streams, including nested collections.</p> <p>Implements a depth-first traversal of the stream hierarchy.</p> <p>Yields:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>All recursively yielded child data streams.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def iter_all(self) -&gt; Generator[DataStream, None, None]:\n    \"\"\"Iterator for all child data streams, including nested collections.\n\n    Implements a depth-first traversal of the stream hierarchy.\n\n    Yields:\n        DataStream: All recursively yielded child data streams.\n    \"\"\"\n    for value in self:\n        if isinstance(value, DataStream):\n            yield value\n        if isinstance(value, DataStreamCollectionBase):\n            yield from value.iter_all()\n</code></pre>"},{"location":"api/contract/text/","title":"contract.text","text":""},{"location":"api/contract/text/#contraqctor.contract.text.TextParams","title":"TextParams  <code>dataclass</code>","text":"<pre><code>TextParams(path: PathLike, encoding: str = 'UTF-8')\n</code></pre> <p>               Bases: <code>FilePathBaseParam</code></p> <p>Parameters for text file processing.</p> <p>Extends the base file path parameters with text encoding configuration.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The character encoding to use when reading the text file. Defaults to UTF-8.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text","title":"Text","text":"<pre><code>Text(\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[TReaderParams] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>DataStream[str, TextParams]</code></p> <p>Text file data stream provider.</p> <p>A data stream implementation for reading text files as a single string with configurable character encoding.</p> <p>Parameters:</p> Name Type Description Default <code>DataStream</code> <p>Base class for data stream providers.</p> required <p>Examples:</p> <pre><code>from contraqctor.contract.text import Text, TextParams\n\n# Create and load a text stream\nparams = TextParams(path=\"README.md\")\nreadme_stream = Text(\"readme\", reader_params=params).load()\n\n# Access the content\ncontent = readme_stream.data\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def __init__(\n    self: Self,\n    name: str,\n    *,\n    description: Optional[str] = None,\n    reader_params: Optional[_typing.TReaderParams] = None,\n    **kwargs,\n) -&gt; None:\n    if \"::\" in name:\n        raise ValueError(\"Name cannot contain '::' character.\")\n    self._name = name\n\n    self._description = description\n    self._reader_params = reader_params if reader_params is not None else _typing.UnsetParams\n    self._data = _typing.UnsetData\n    self._parent: Optional[\"DataStream\"] = None\n</code></pre>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the data stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name identifier of the data stream.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.resolved_name","title":"resolved_name  <code>property</code>","text":"<pre><code>resolved_name: str\n</code></pre> <p>Get the full hierarchical name of the data stream.</p> <p>Generates a path-like name showing the stream's position in the hierarchy, using '::' as a separator between parent and child names.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully resolved name including all parent names.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the data stream.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Description of the data stream, or None if not provided.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: Optional[DataStream]\n</code></pre> <p>Get the parent data stream.</p> <p>Returns:</p> Type Description <code>Optional[DataStream]</code> <p>Optional[DataStream]: Parent data stream, or None if this is a root stream.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.is_collection","title":"is_collection  <code>property</code>","text":"<pre><code>is_collection: bool\n</code></pre> <p>Check if this data stream is a collection of other streams.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this is a collection stream, False otherwise.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.reader_params","title":"reader_params  <code>property</code>","text":"<pre><code>reader_params: TReaderParams\n</code></pre> <p>Get the parameters for the data reader.</p> <p>Returns:</p> Name Type Description <code>TReaderParams</code> <code>TReaderParams</code> <p>Parameters for the data reader.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.has_data","title":"has_data  <code>property</code>","text":"<pre><code>has_data: bool\n</code></pre> <p>Check if the data stream has loaded data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if data has been loaded, False otherwise.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.data","title":"data  <code>property</code>","text":"<pre><code>data: TData\n</code></pre> <p>Get the loaded data.</p> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has not been loaded yet.</p>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.read","title":"read","text":"<pre><code>read(\n    reader_params: Optional[TReaderParams] = None,\n) -&gt; TData\n</code></pre> <p>Read data using the configured reader.</p> <p>Parameters:</p> Name Type Description Default <code>reader_params</code> <code>Optional[TReaderParams]</code> <p>Optional parameters to override the default reader parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TData</code> <code>TData</code> <p>Data read from the source.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters are not set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def read(self, reader_params: Optional[_typing.TReaderParams] = None) -&gt; _typing.TData:\n    \"\"\"Read data using the configured reader.\n\n    Args:\n        reader_params: Optional parameters to override the default reader parameters.\n\n    Returns:\n        TData: Data read from the source.\n\n    Raises:\n        ValueError: If reader parameters are not set.\n    \"\"\"\n    reader_params = reader_params if reader_params is not None else self._reader_params\n    if _typing.is_unset(reader_params):\n        raise ValueError(\"Reader parameters are not set. Cannot read data.\")\n    return self._reader(reader_params)\n</code></pre>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.bind_reader_params","title":"bind_reader_params","text":"<pre><code>bind_reader_params(params: TReaderParams) -&gt; Self\n</code></pre> <p>Bind reader parameters to the data stream.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>TReaderParams</code> <p>Parameters to bind to the data stream's reader.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If reader parameters have already been set.</p> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def bind_reader_params(self, params: _typing.TReaderParams) -&gt; Self:\n    \"\"\"Bind reader parameters to the data stream.\n\n    Args:\n        params: Parameters to bind to the data stream's reader.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Raises:\n        ValueError: If reader parameters have already been set.\n    \"\"\"\n    if not _typing.is_unset(self._reader_params):\n        raise ValueError(\"Reader parameters are already set. Cannot bind again.\")\n    self._reader_params = params\n    return self\n</code></pre>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.at","title":"at","text":"<pre><code>at(name: str) -&gt; DataStream\n</code></pre> <p>Get a child data stream by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the child data stream to retrieve.</p> required <p>Returns:</p> Name Type Description <code>DataStream</code> <code>DataStream</code> <p>The child data stream with the given name.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the data stream does not support child access.</p> <p>Examples:</p> <pre><code># Access stream in a collection\ncollection = data_collection.load()\ntemp_stream = collection.at(\"temperature\")\n\n# Or using dictionary-style syntax\nhumidity_stream = collection[\"humidity\"]\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def at(self, name: str) -&gt; \"DataStream\":\n    \"\"\"Get a child data stream by name.\n\n    Args:\n        name: Name of the child data stream to retrieve.\n\n    Returns:\n        DataStream: The child data stream with the given name.\n\n    Raises:\n        NotImplementedError: If the data stream does not support child access.\n\n    Examples:\n        ```python\n        # Access stream in a collection\n        collection = data_collection.load()\n        temp_stream = collection.at(\"temperature\")\n\n        # Or using dictionary-style syntax\n        humidity_stream = collection[\"humidity\"]\n        ```\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented for DataStream.\")\n</code></pre>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.load","title":"load","text":"<pre><code>load() -&gt; Self\n</code></pre> <p>Load data into the data stream.</p> <p>Reads data from the source and stores it in the data stream.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The data stream instance for method chaining.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import csv\n\n# Create and load a CSV stream\nparams = csv.CsvParams(path=\"data/measurements.csv\")\ncsv_stream = csv.Csv(\"measurements\", reader_params=params)\ncsv_stream.load()\n\n# Access the data\ndf = csv_stream.data\nprint(f\"Loaded {len(df)} rows\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load(self) -&gt; Self:\n    \"\"\"Load data into the data stream.\n\n    Reads data from the source and stores it in the data stream.\n\n    Returns:\n        Self: The data stream instance for method chaining.\n\n    Examples:\n        ```python\n        from contraqctor.contract import csv\n\n        # Create and load a CSV stream\n        params = csv.CsvParams(path=\"data/measurements.csv\")\n        csv_stream = csv.Csv(\"measurements\", reader_params=params)\n        csv_stream.load()\n\n        # Access the data\n        df = csv_stream.data\n        print(f\"Loaded {len(df)} rows\")\n        ```\n    \"\"\"\n    self._data = self.read()\n    return self\n</code></pre>"},{"location":"api/contract/text/#contraqctor.contract.text.Text.load_all","title":"load_all","text":"<pre><code>load_all(\n    strict: bool = False,\n) -&gt; list[tuple[DataStream, Exception], None, None]\n</code></pre> <p>Recursively load this data stream and all child streams.</p> <p>Performs depth-first traversal to load all streams in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises exceptions immediately; otherwise collects and returns them.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[DataStream, Exception], None, None]</code> <p>List of tuples containing streams and exceptions that occurred during loading.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If strict is True and an exception occurs during loading.</p> <p>Examples:</p> <pre><code># Load all streams and handle errors\nerrors = collection.load_all(strict=False)\n\nif errors:\n    for stream, error in errors:\n        print(f\"Error loading {stream.name}: {error}\")\n</code></pre> Source code in <code>src/contraqctor/contract/base.py</code> <pre><code>def load_all(self, strict: bool = False) -&gt; list[tuple[\"DataStream\", Exception], None, None]:\n    \"\"\"Recursively load this data stream and all child streams.\n\n    Performs depth-first traversal to load all streams in the hierarchy.\n\n    Args:\n        strict: If True, raises exceptions immediately; otherwise collects and returns them.\n\n    Returns:\n        list: List of tuples containing streams and exceptions that occurred during loading.\n\n    Raises:\n        Exception: If strict is True and an exception occurs during loading.\n\n    Examples:\n        ```python\n        # Load all streams and handle errors\n        errors = collection.load_all(strict=False)\n\n        if errors:\n            for stream, error in errors:\n                print(f\"Error loading {stream.name}: {error}\")\n        ```\n    \"\"\"\n    self.load()\n    exceptions = []\n    for stream in self:\n        if stream is None:\n            continue\n        try:\n            exceptions += stream.load_all(strict=strict)\n        except Exception as e:\n            if strict:\n                raise e\n            exceptions.append((stream, e))\n    return exceptions\n</code></pre>"},{"location":"api/contract/utils/","title":"contract.utils","text":""},{"location":"api/contract/utils/#contraqctor.contract.utils.print_data_stream_tree","title":"print_data_stream_tree","text":"<pre><code>print_data_stream_tree(\n    node: DataStream,\n    prefix: str = \"\",\n    is_last: bool = True,\n    parents: list[bool] = [],\n    show_params: bool = False,\n    show_type: bool = False,\n    show_missing_indicator: bool = True,\n) -&gt; str\n</code></pre> <p>Generates a tree representation of a data stream hierarchy.</p> <p>Creates a formatted string displaying the hierarchical structure of a data stream and its children as a tree with branch indicators and icons.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DataStream</code> <p>The data stream node to start printing from.</p> required <code>prefix</code> <code>str</code> <p>Prefix string to prepend to each line, used for indentation.</p> <code>''</code> <code>is_last</code> <code>bool</code> <p>Whether this node is the last child of its parent.</p> <code>True</code> <code>parents</code> <code>list[bool]</code> <p>List tracking whether each ancestor was a last child, used for drawing branches.</p> <code>[]</code> <code>show_params</code> <code>bool</code> <p>Whether to render parameters of the datastream.</p> <code>False</code> <code>show_type</code> <code>bool</code> <p>Whether to render the class name of the datastream.</p> <code>False</code> <code>show_missing_indicator</code> <code>bool</code> <p>Whether to render the missing data indicator.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string representing the data stream tree.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import Dataset, csv, json\nfrom contraqctor.contract.utils import print_data_stream_tree\n\n# Create a dataset with streams\ncsv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\njson_stream = json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\ndataset = Dataset(\"experiment\", [csv_stream, json_stream], version=\"1.0.0\")\n\n# Print the tree\ntree = print_data_stream_tree(dataset)\nprint(tree)\n# Output:\n# \ud83d\udcc2 experiment\n# \u251c\u2500\u2500 \ud83d\udcc4 data\n# \u2514\u2500\u2500 \ud83d\udcc4 config\n</code></pre> Source code in <code>src/contraqctor/contract/utils.py</code> <pre><code>def print_data_stream_tree(\n    node: DataStream,\n    prefix: str = \"\",\n    is_last: bool = True,\n    parents: list[bool] = [],\n    show_params: bool = False,\n    show_type: bool = False,\n    show_missing_indicator: bool = True,\n) -&gt; str:\n    \"\"\"Generates a tree representation of a data stream hierarchy.\n\n    Creates a formatted string displaying the hierarchical structure of a data stream\n    and its children as a tree with branch indicators and icons.\n\n    Args:\n        node: The data stream node to start printing from.\n        prefix: Prefix string to prepend to each line, used for indentation.\n        is_last: Whether this node is the last child of its parent.\n        parents: List tracking whether each ancestor was a last child, used for drawing branches.\n        show_params: Whether to render parameters of the datastream.\n        show_type: Whether to render the class name of the datastream.\n        show_missing_indicator: Whether to render the missing data indicator.\n\n    Returns:\n        str: A formatted string representing the data stream tree.\n\n    Examples:\n        ```python\n        from contraqctor.contract import Dataset, csv, json\n        from contraqctor.contract.utils import print_data_stream_tree\n\n        # Create a dataset with streams\n        csv_stream = csv.Csv(\"data\", reader_params=csv.CsvParams(path=\"data.csv\"))\n        json_stream = json.Json(\"config\", reader_params=json.JsonParams(path=\"config.json\"))\n        dataset = Dataset(\"experiment\", [csv_stream, json_stream], version=\"1.0.0\")\n\n        # Print the tree\n        tree = print_data_stream_tree(dataset)\n        print(tree)\n        # Output:\n        # \ud83d\udcc2 experiment\n        # \u251c\u2500\u2500 \ud83d\udcc4 data\n        # \u2514\u2500\u2500 \ud83d\udcc4 config\n        ```\n    \"\"\"\n    icon_map = {\n        False: \"\ud83d\udcc4\",\n        True: \"\ud83d\udcc2\",\n        None: \"\u2753\",\n    }\n\n    node_icon = icon_map[node.is_collection]\n    if not node.has_data and show_missing_indicator:\n        node_icon += f\"{icon_map[None]}\"\n\n    line_prefix = \"\"\n    for parent_is_last in parents[:-1]:\n        line_prefix += \"    \" if parent_is_last else \"\u2502   \"\n\n    if parents:\n        branch = \"\u2514\u2500\u2500 \" if is_last else \"\u251c\u2500\u2500 \"\n        line_prefix += branch\n\n    # Build node label with name, type, and parameters\n    node_label = node.name\n\n    if show_type:\n        node_label += f\" [{node.__class__.__name__}]\"\n\n    if show_params and hasattr(node, \"reader_params\") and node.reader_params:\n        params_str = str(node.reader_params)\n        node_label += f\" ({params_str})\"\n\n    tree_representation = f\"{line_prefix}{node_icon} {node_label}\\n\"\n\n    if node.is_collection and node.has_data:\n        for i, child in enumerate(node.data):\n            child_is_last = i == len(node.data) - 1\n            tree_representation += print_data_stream_tree(\n                child,\n                prefix=\"\",\n                is_last=child_is_last,\n                parents=parents + [is_last],\n                show_params=show_params,\n                show_type=show_type,\n                show_missing_indicator=show_missing_indicator,\n            )\n\n    return tree_representation\n</code></pre>"},{"location":"api/qc/base/","title":"qc.base","text":""},{"location":"api/qc/base/#contraqctor.qc.base.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing possible test result statuses.</p> <p>Defines the different states a test can be in after execution.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.ITest","title":"ITest","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for test functions.</p> <p>A test function should be callable, return a Result object or generator, and have a name attribute.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(\n    status: Status,\n    result: TResult,\n    test_name: str,\n    suite_name: str,\n    message: Optional[str] = None,\n    context: Optional[Any] = None,\n    description: Optional[str] = None,\n    exception: Optional[Exception] = None,\n    traceback: Optional[str] = None,\n    test_reference: Optional[ITest] = None,\n    suite_reference: Optional[Suite] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[TResult]</code></p> <p>Container for test execution results.</p> <p>Stores the outcome of a test execution including status, returned value, contextual information, and any exception details.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>Status</code> <p>The status of the test execution.</p> <code>result</code> <code>TResult</code> <p>The value returned by the test.</p> <code>test_name</code> <code>str</code> <p>Name of the test that generated this result.</p> <code>suite_name</code> <code>str</code> <p>Name of the test suite containing the test.</p> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the test outcome.</p> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the test.</p> <code>exception</code> <code>Optional[Exception]</code> <p>Optional exception that occurred during test execution.</p> <code>traceback</code> <code>Optional[str]</code> <p>Optional traceback string if an exception occurred.</p> <code>test_reference</code> <code>Optional[ITest]</code> <p>Optional reference to the test function.</p> <code>suite_reference</code> <code>Optional[Suite]</code> <p>Optional reference to the suite that ran this test.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite","title":"Suite","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for test suites.</p> <p>Provides the core functionality for defining, running, and reporting on tests. All test suites should inherit from this class and implement test methods that start with 'test'.</p> <p>Examples:</p> <pre><code>from contraqctor.qc.base import Suite\n\nclass MyTestSuite(Suite):\n    \"\"\"Test suite for validating my component.\"\"\"\n\n    def __init__(self, component):\n        self.component = component\n\n    def test_has_required_property(self):\n        if hasattr(self.component, \"required_property\"):\n            return self.pass_test(True, \"Component has required property\")\n        else:\n            return self.fail_test(False, \"Component is missing required property\")\n\n    def test_performs_calculation(self):\n        try:\n            result = self.component.calculate(10)\n            if result == 20:\n                return self.pass_test(result, \"Calculation correct\")\n            else:\n                return self.fail_test(result, f\"Expected 20 but got {result}\")\n        except Exception as e:\n            return self.fail_test(None, f\"Calculation failed: {str(e)}\")\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Suite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.ResultsStatistics","title":"ResultsStatistics  <code>dataclass</code>","text":"<pre><code>ResultsStatistics(\n    passed: int,\n    failed: int,\n    error: int,\n    skipped: int,\n    warnings: int,\n)\n</code></pre> <p>Statistics about test results.</p> <p>Aggregates counts of test results by status and provides methods for calculating statistics like pass rate.</p> <p>Attributes:</p> Name Type Description <code>passed</code> <code>int</code> <p>Number of passed tests.</p> <code>failed</code> <code>int</code> <p>Number of failed tests.</p> <code>error</code> <code>int</code> <p>Number of tests that produced errors.</p> <code>skipped</code> <code>int</code> <p>Number of skipped tests.</p> <code>warnings</code> <code>int</code> <p>Number of tests with warnings.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.ResultsStatistics.total","title":"total  <code>property</code>","text":"<pre><code>total: int\n</code></pre> <p>Get the total number of tests.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sum of all test result counts.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.ResultsStatistics.pass_rate","title":"pass_rate  <code>property</code>","text":"<pre><code>pass_rate: float\n</code></pre> <p>Calculate the pass rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ratio of passed tests to total tests, or 0 if no tests.</p>"},{"location":"api/qc/base/#contraqctor.qc.base.ResultsStatistics.get_status_summary","title":"get_status_summary","text":"<pre><code>get_status_summary() -&gt; str\n</code></pre> <p>Generate a compact string summary of result counts.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Summary string with counts for each status type.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_status_summary(self) -&gt; str:\n    \"\"\"Generate a compact string summary of result counts.\n\n    Returns:\n        str: Summary string with counts for each status type.\n    \"\"\"\n    return f\"P:{self[Status.PASSED]} F:{self[Status.FAILED]} E:{self[Status.ERROR]} S:{self[Status.SKIPPED]} W:{self[Status.WARNING]}\"\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.ResultsStatistics.from_results","title":"from_results  <code>classmethod</code>","text":"<pre><code>from_results(results: List[Result]) -&gt; ResultsStatistics\n</code></pre> <p>Create statistics from a list of test results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Result]</code> <p>List of test results to analyze.</p> required <p>Returns:</p> Name Type Description <code>ResultsStatistics</code> <code>ResultsStatistics</code> <p>Statistics object summarizing the results.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@classmethod\ndef from_results(cls, results: t.List[Result]) -&gt; \"ResultsStatistics\":\n    \"\"\"Create statistics from a list of test results.\n\n    Args:\n        results: List of test results to analyze.\n\n    Returns:\n        ResultsStatistics: Statistics object summarizing the results.\n    \"\"\"\n    stats = {status: sum(1 for r in results if r.status == status) for status in Status}\n    return cls(\n        passed=stats[Status.PASSED],\n        failed=stats[Status.FAILED],\n        error=stats[Status.ERROR],\n        skipped=stats[Status.SKIPPED],\n        warnings=stats[Status.WARNING],\n    )\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Runner","title":"Runner","text":"<pre><code>Runner()\n</code></pre> <p>Test runner for executing suites and reporting results.</p> <p>Handles executing test suites, collecting results, and generating reports.</p> <p>Attributes:</p> Name Type Description <code>suites</code> <code>Dict[Optional[str], List[Suite]]</code> <p>Dictionary mapping group names to lists of test suites.</p> <code>_results</code> <code>Optional[List[_TaggedResult]]</code> <p>Optional dictionary of collected test results by group.</p> <p>Examples:</p> <pre><code>from contraqctor.qc.base import Runner\n\n# Create test suites\nsuite1 = MyTestSuite(component1)\nsuite2 = AnotherTestSuite(component2)\nsuite3 = YetAnotherTestSuite(component2)\n\n# Create runner and add suites with group names\nrunner = Runner()\nrunner.add_suite(suite1, \"Component Tests\")\nrunner.add_suite(suite2, \"Integration Tests\")\nrunner.add_suite(suite3, \"Integration Tests\")\n\n# Run all tests with progress display\nresults = runner.run_all_with_progress()\n\n# Access results by group\ncomponent_results = results[\"Component Tests\"]\n</code></pre> <p>Initialize the test runner.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the test runner.\"\"\"\n    self.suites: t.Dict[t.Optional[str], t.List[Suite]] = {}\n    self._results: t.Optional[t.List[_TaggedResult]] = None\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Runner.add_suite","title":"add_suite","text":"<pre><code>add_suite(suite: Suite) -&gt; Self\n</code></pre><pre><code>add_suite(suite: Suite, group: str) -&gt; Self\n</code></pre> <pre><code>add_suite(\n    suite: Suite, group: Optional[str] = None\n) -&gt; Self\n</code></pre> <p>Add a test suite to the runner.</p> <p>Parameters:</p> Name Type Description Default <code>suite</code> <code>Suite</code> <p>Test suite to add.</p> required <code>group</code> <code>Optional[str]</code> <p>Optional group name for organizing suites. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Runner</code> <code>Self</code> <p>Self for method chaining.</p> <p>Examples:</p> <pre><code>runner = Runner()\n\n# Add a suite without a group\nrunner.add_suite(BasicSuite())\n\n# Add suites with named groups for organization\nrunner.add_suite(DataSuite(), \"Data Validation\")\nrunner.add_suite(VisualizationSuite(), \"Data Validation\")\nrunner.add_suite(ApiSuite(), \"API Tests\")\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def add_suite(self, suite: Suite, group: t.Optional[str] = None) -&gt; t.Self:\n    \"\"\"Add a test suite to the runner.\n\n    Args:\n        suite: Test suite to add.\n        group: Optional group name for organizing suites. Defaults to None.\n\n    Returns:\n        Runner: Self for method chaining.\n\n    Examples:\n        ```python\n        runner = Runner()\n\n        # Add a suite without a group\n        runner.add_suite(BasicSuite())\n\n        # Add suites with named groups for organization\n        runner.add_suite(DataSuite(), \"Data Validation\")\n        runner.add_suite(VisualizationSuite(), \"Data Validation\")\n        runner.add_suite(ApiSuite(), \"API Tests\")\n        ```\n    \"\"\"\n    self._update_suites(suite, group)\n    return self\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.Runner.run_all_with_progress","title":"run_all_with_progress","text":"<pre><code>run_all_with_progress(\n    *,\n    render_context: bool = True,\n    render_description: bool = True,\n    render_traceback: bool = True,\n    render_message: bool = True,\n) -&gt; Dict[Optional[str], List[Result]]\n</code></pre> <p>Run all tests in all suites with a rich progress display.</p> <p>Executes all tests with a visual progress bar and detailed reporting of test outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>render_context</code> <code>bool</code> <p>Whether to render test context in result output.</p> <code>True</code> <code>render_description</code> <code>bool</code> <p>Whether to render test descriptions in result output.</p> <code>True</code> <code>render_traceback</code> <code>bool</code> <p>Whether to render tracebacks for errors in result output.</p> <code>True</code> <code>render_message</code> <code>bool</code> <p>Whether to render test result messages in result output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[Optional[str], List[Result]]</code> <p>Dict[Optional[str], List[Result]]: Results grouped by test group name.</p> <p>Examples:</p> <pre><code>runner = Runner()\nrunner.add_suite(DataValidationSuite(), \"Validation\")\nrunner.add_suite(PerformanceSuite(), \"Performance\")\n\n# Run all tests with progress display and complete output\nresults = runner.run_all_with_progress()\n\n# Run with simplified output (no context or traceback)\nresults = runner.run_all_with_progress(\n    render_context=False,\n    render_traceback=False\n)\n\n# Check if any tests failed\nall_passed = all(\n    result.status == Status.PASSED\n    for group_results in results.values()\n    for result in group_results\n)\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all_with_progress(\n    self,\n    *,\n    render_context: bool = True,\n    render_description: bool = True,\n    render_traceback: bool = True,\n    render_message: bool = True,\n) -&gt; t.Dict[t.Optional[str], t.List[Result]]:\n    \"\"\"Run all tests in all suites with a rich progress display.\n\n    Executes all tests with a visual progress bar and detailed reporting\n    of test outcomes.\n\n    Args:\n        render_context: Whether to render test context in result output.\n        render_description: Whether to render test descriptions in result output.\n        render_traceback: Whether to render tracebacks for errors in result output.\n        render_message: Whether to render test result messages in result output.\n\n    Returns:\n        Dict[Optional[str], List[Result]]: Results grouped by test group name.\n\n    Examples:\n        ```python\n        runner = Runner()\n        runner.add_suite(DataValidationSuite(), \"Validation\")\n        runner.add_suite(PerformanceSuite(), \"Performance\")\n\n        # Run all tests with progress display and complete output\n        results = runner.run_all_with_progress()\n\n        # Run with simplified output (no context or traceback)\n        results = runner.run_all_with_progress(\n            render_context=False,\n            render_traceback=False\n        )\n\n        # Check if any tests failed\n        all_passed = all(\n            result.status == Status.PASSED\n            for group_results in results.values()\n            for result in group_results\n        )\n        ```\n    \"\"\"\n\n    collected_tests = self._collect_tests()\n    total_test_count = len(collected_tests)\n\n    suite_name_lengths = [len(suite.name) for suite, _ in _TaggedTest.group_by_suite(collected_tests)]\n    # we sum 2 to account for brackets\n    group_lengths = [\n        len(group) + 2 for group, _ in _TaggedTest.group_by_group(collected_tests) if group is not None\n    ]\n    full_name_width = max(suite_name_lengths + group_lengths) if suite_name_lengths else 10\n    test_name_width = 20  # To render the test name during progress\n    bar_width = 20\n\n    progress_format = [\n        f\"[progress.description]{{task.description:&lt;{full_name_width + test_name_width + 5}}}\",\n        rich.progress.BarColumn(),\n        \"[progress.percentage]{task.percentage:&gt;3.0f}%\",\n        \"\u2022\",\n        rich.progress.TimeElapsedColumn(),\n    ]\n\n    with rich.progress.Progress(*progress_format) as progress:\n        total_task = progress.add_task(\n            \"[bold green]TOTAL PROGRESS\".ljust(full_name_width + test_name_width + 5), total=total_test_count\n        )\n\n        collected_results: t.List[_TaggedResult] = []\n        for group, tests_in_group in _TaggedTest.group_by_group(collected_tests):\n            _title = (\n                rich.markup.escape(f\"[{group}]\") if group else rich.markup.escape(f\"[{self._DEFAULT_TEST_GROUP}]\")\n            )\n            group_task = progress.add_task(\n                f\"[honeydew2]{_title}\".ljust(full_name_width + test_name_width + 5),\n                total=len(tests_in_group),\n            )\n            for suite, tests_in_suite in _TaggedTest.group_by_suite(tests_in_group):\n                results = self._run_suite_tests(\n                    progress,\n                    suite,\n                    [t.test for t in tests_in_suite],\n                    full_name_width,\n                    test_name_width,\n                    total_task,\n                    group_task,\n                )\n                for result in results:\n                    collected_results.append(\n                        _TaggedResult(suite=suite, group=group, result=result, test=result.test_reference)\n                    )\n\n            if len(_TaggedResult.get_by_group(collected_results, group)) &gt; 0:\n                group_results = [\n                    tagged_result.result for tagged_result in _TaggedResult.get_by_group(collected_results, group)\n                ]\n                group_stats = ResultsStatistics.from_results(group_results)\n                group_status_bar = self._render_status_bar(group_stats, bar_width)\n                padding_width = max(0, full_name_width - len(self._rich_unscape(_title)))\n                group_line = f\"[honeydew2]{_title}{' ' * padding_width} | {group_status_bar} | {group_stats.get_status_summary()}\"\n                progress.update(group_task, description=group_line)\n\n        if total_test_count &gt; 0:\n            total_stats = ResultsStatistics.from_results(\n                [tagged_result.result for tagged_result in collected_results]\n            )\n            total_status_bar = self._render_status_bar(total_stats, bar_width)\n\n            _title = \"TOTAL PROGRESS\"\n            # Fix: Use max() to ensure padding width is never negative\n            padding_width = max(0, full_name_width - len(_title))\n            total_line = f\"[bold green]{_title}{' ' * padding_width} | {total_status_bar} | {total_stats.get_status_summary()}\"\n            progress.update(total_task, description=total_line)\n\n    self._results = collected_results\n    if self._results:\n        self._print_results(\n            self._results,\n            render_description=render_description,\n            render_traceback=render_traceback,\n            render_message=render_message,\n            render_context=render_context,\n        )\n\n    out: t.Dict[t.Optional[str], t.List[Result]] = {}\n    for group, grouped_results in _TaggedResult.group_by_group(collected_results):\n        out[group] = [tagged_result.result for tagged_result in grouped_results]\n    return out\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.allow_null_as_pass","title":"allow_null_as_pass","text":"<pre><code>allow_null_as_pass(value: bool = True)\n</code></pre> <p>Context manager to control whether null results are allowed as pass.</p> <p>When enabled, tests that return None will be treated as passing tests rather than producing errors.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to allow null results as passing, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import allow_null_as_pass, Runner\n\n# Create a test suite with methods that return None\nclass SimpleTestSuite(Suite):\n    def test_basic_check(self):\n        # This method returns None, which would normally be an error\n        print(\"Performing a check\")\n        # No explicit return\n\n# Run with allow_null_as_pass to treat None returns as passing\nsuite = SimpleTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith allow_null_as_pass():\n    # None returns will be treated as passing tests\n    results = runner.run_all_with_progress()\n\n# Outside the context manager, None returns would cause errors\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef allow_null_as_pass(value: bool = True):\n    \"\"\"Context manager to control whether null results are allowed as pass.\n\n    When enabled, tests that return None will be treated as passing tests\n    rather than producing errors.\n\n    Args:\n        value: True to allow null results as passing, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import allow_null_as_pass, Runner\n\n        # Create a test suite with methods that return None\n        class SimpleTestSuite(Suite):\n            def test_basic_check(self):\n                # This method returns None, which would normally be an error\n                print(\"Performing a check\")\n                # No explicit return\n\n        # Run with allow_null_as_pass to treat None returns as passing\n        suite = SimpleTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with allow_null_as_pass():\n            # None returns will be treated as passing tests\n            results = runner.run_all_with_progress()\n\n        # Outside the context manager, None returns would cause errors\n        ```\n    \"\"\"\n    token = _allow_null_as_pass_ctx.set(value)\n    try:\n        yield\n    finally:\n        _allow_null_as_pass_ctx.reset(token)\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.elevated_skips","title":"elevated_skips","text":"<pre><code>elevated_skips(value: bool = True)\n</code></pre> <p>Context manager to control whether skipped tests are treated as failures.</p> <p>When enabled, skipped tests will be treated as failing tests rather than being merely marked as skipped.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to elevate skipped tests to failures, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import elevated_skips, Runner\n\n# Create a test suite with some skipped tests\nclass FeatureTestSuite(Suite):\n    def test_implemented_feature(self):\n        return self.pass_test(True, \"Feature works\")\n\n    def test_unimplemented_feature(self):\n        return self.skip_test(\"Feature not yet implemented\")\n\n# Run with elevated_skips to fail when tests are skipped\nsuite = FeatureTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith elevated_skips():\n    # Skipped tests will be treated as failures\n    results = runner.run_all_with_progress()\n\n# Without the context manager, skips are just marked as skipped\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef elevated_skips(value: bool = True):\n    \"\"\"Context manager to control whether skipped tests are treated as failures.\n\n    When enabled, skipped tests will be treated as failing tests rather than\n    being merely marked as skipped.\n\n    Args:\n        value: True to elevate skipped tests to failures, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import elevated_skips, Runner\n\n        # Create a test suite with some skipped tests\n        class FeatureTestSuite(Suite):\n            def test_implemented_feature(self):\n                return self.pass_test(True, \"Feature works\")\n\n            def test_unimplemented_feature(self):\n                return self.skip_test(\"Feature not yet implemented\")\n\n        # Run with elevated_skips to fail when tests are skipped\n        suite = FeatureTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with elevated_skips():\n            # Skipped tests will be treated as failures\n            results = runner.run_all_with_progress()\n\n        # Without the context manager, skips are just marked as skipped\n        ```\n    \"\"\"\n    token = _elevate_skippable.set(value)\n    try:\n        yield\n    finally:\n        _elevate_skippable.reset(token)\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.elevated_warnings","title":"elevated_warnings","text":"<pre><code>elevated_warnings(value: bool = True)\n</code></pre> <p>Context manager to control whether warnings are treated as failures.</p> <p>When enabled, warning results will be treated as failing tests rather than just being marked as warnings.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to elevate warnings to failures, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import elevated_warnings, Runner\n\n# Create a test suite with warning conditions\nclass PerformanceTestSuite(Suite):\n    def test_response_time(self):\n        response_time = measure_response()\n\n        if response_time &lt; 100:\n            return self.pass_test(response_time, \"Response time acceptable\")\n        elif response_time &lt; 200:\n            # This would normally be a warning\n            return self.warn_test(response_time, \"Response time degraded\")\n        else:\n            return self.fail_test(response_time, \"Response time unacceptable\")\n\n# Run with elevated_warnings to fail on warnings\nsuite = PerformanceTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith elevated_warnings():\n    # Warning results will be treated as failures\n    # Useful in CI/CD pipelines where warnings should trigger failures\n    results = runner.run_all_with_progress()\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef elevated_warnings(value: bool = True):\n    \"\"\"Context manager to control whether warnings are treated as failures.\n\n    When enabled, warning results will be treated as failing tests rather than\n    just being marked as warnings.\n\n    Args:\n        value: True to elevate warnings to failures, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import elevated_warnings, Runner\n\n        # Create a test suite with warning conditions\n        class PerformanceTestSuite(Suite):\n            def test_response_time(self):\n                response_time = measure_response()\n\n                if response_time &lt; 100:\n                    return self.pass_test(response_time, \"Response time acceptable\")\n                elif response_time &lt; 200:\n                    # This would normally be a warning\n                    return self.warn_test(response_time, \"Response time degraded\")\n                else:\n                    return self.fail_test(response_time, \"Response time unacceptable\")\n\n        # Run with elevated_warnings to fail on warnings\n        suite = PerformanceTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with elevated_warnings():\n            # Warning results will be treated as failures\n            # Useful in CI/CD pipelines where warnings should trigger failures\n            results = runner.run_all_with_progress()\n        ```\n    \"\"\"\n    token = _elevate_warning.set(value)\n    try:\n        yield\n    finally:\n        _elevate_warning.reset(token)\n</code></pre>"},{"location":"api/qc/base/#contraqctor.qc.base.implicit_pass","title":"implicit_pass","text":"<pre><code>implicit_pass(\n    func: Callable[..., Any],\n) -&gt; Callable[..., Result]\n</code></pre> <p>Decorator to automatically convert non-Result return values to passing results.</p> <p>If a test method returns something other than a Result object, this decorator will wrap it in a passing Result with the original return value.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to decorate.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <code>Callable[..., Result]</code> <p>Decorated function that ensures Result objects are returned.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the decorated function is not a method of a Suite object.</p> <p>Examples:</p> <pre><code>from contraqctor.qc.base import Suite, implicit_pass\n\nclass SimplifiedTestSuite(Suite):\n    # Regular test method that explicitly returns a Result object\n    def test_regular_approach(self):\n        value = 42\n        return self.pass_test(value, \"Explicitly created pass result\")\n\n    # Using the decorator to simplify - just return the value\n    @implicit_pass\n    def test_implicit_approach(self):\n        # This will automatically be wrapped in a passing Result\n        return 42\n\n    # The decorator handles different return types\n    @implicit_pass\n    def test_with_dict(self):\n        # This dictionary will be wrapped in a passing Result\n        return {\"status\": \"ok\", \"value\": 100}\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def implicit_pass(func: t.Callable[..., t.Any]) -&gt; t.Callable[..., Result]:\n    \"\"\"Decorator to automatically convert non-Result return values to passing results.\n\n    If a test method returns something other than a Result object, this decorator\n    will wrap it in a passing Result with the original return value.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        callable: Decorated function that ensures Result objects are returned.\n\n    Raises:\n        TypeError: If the decorated function is not a method of a Suite object.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import Suite, implicit_pass\n\n        class SimplifiedTestSuite(Suite):\n            # Regular test method that explicitly returns a Result object\n            def test_regular_approach(self):\n                value = 42\n                return self.pass_test(value, \"Explicitly created pass result\")\n\n            # Using the decorator to simplify - just return the value\n            @implicit_pass\n            def test_implicit_approach(self):\n                # This will automatically be wrapped in a passing Result\n                return 42\n\n            # The decorator handles different return types\n            @implicit_pass\n            def test_with_dict(self):\n                # This dictionary will be wrapped in a passing Result\n                return {\"status\": \"ok\", \"value\": 100}\n        ```\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self: Suite, *args: t.Any, **kwargs: t.Any) -&gt; Result:\n        \"\"\"Wrapper function to ensure the decorated function returns a Result.\"\"\"\n        result = func(self, *args, **kwargs)\n\n        if isinstance(result, Result):\n            return result\n\n        # Just in case someone tries to do funny stuff\n        if isinstance(self, Suite):\n            return self.pass_test(result=result, message=f\"Auto-converted return value: {result}\")\n        else:\n            # Not in a Suite - can't convert properly\n            raise TypeError(\n                f\"The auto_test decorator was used on '{func.__name__}' in a non-Suite \"\n                f\"class ({self.__class__.__name__}). This is not supported.\"\n            )\n\n    return wrapper\n</code></pre>"},{"location":"api/qc/camera/","title":"qc.camera","text":""},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite","title":"CameraTestSuite","text":"<pre><code>CameraTestSuite(\n    data_stream: Camera,\n    *,\n    expected_fps: Optional[int] = None,\n    clock_jitter_s: float = 0.0001,\n    start_time_s: Optional[float] = None,\n    stop_time_s: Optional[float] = None,\n)\n</code></pre> <p>               Bases: <code>Suite</code></p> <p>Test suite for validating camera data integrity.</p> <p>Provides tests for validating video and metadata integrity according to the AIND file format specification for behavior videos.</p> <p>For more details, see: https://github.com/AllenNeuralDynamics/aind-file-standards/blob/ce0aa517a40064d1ac9764d42c9efe4ae5c61f7b/file_formats/behavior_videos.md</p> <p>Attributes:</p> Name Type Description <code>data_stream</code> <code>Camera</code> <p>The Camera data stream to test.</p> <code>expected_fps</code> <p>Optional expected frames per second for validation.</p> <code>clock_jitter_s</code> <p>Maximum allowed time difference between frame timestamps, in seconds.</p> <code>start_time_s</code> <p>Optional expected start time for validation, in seconds.</p> <code>stop_time_s</code> <p>Optional expected stop time for validation, in seconds.</p> <p>Examples:</p> <pre><code>from contraqctor.contract.camera import Camera, CameraParams\nfrom contraqctor.qc.camera import CameraTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create and load a camera data stream\nparams = CameraParams(path=\"recordings/session1/\")\ncamera_stream = Camera(\"front_camera\", reader_params=params).load()\n\n# Create test suite with validation parameters\nsuite = CameraTestSuite(\n    camera_stream,\n    expected_fps=30,\n    start_time_s=10.0,\n    stop_time_s=310.0\n)\n\n# Run tests\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the camera test suite.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>Camera</code> <p>The Camera data stream to test.</p> required <code>expected_fps</code> <code>Optional[int]</code> <p>Optional expected frames per second for validation.</p> <code>None</code> <code>clock_jitter_s</code> <code>float</code> <p>Maximum allowed time difference between frame timestamps, in seconds.</p> <code>0.0001</code> <code>start_time_s</code> <code>Optional[float]</code> <p>Optional expected start time for validation, in seconds.</p> <code>None</code> <code>stop_time_s</code> <code>Optional[float]</code> <p>Optional expected stop time for validation, in seconds.</p> <code>None</code> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def __init__(\n    self,\n    data_stream: Camera,\n    *,\n    expected_fps: t.Optional[int] = None,\n    clock_jitter_s: float = 1e-4,\n    start_time_s: t.Optional[float] = None,\n    stop_time_s: t.Optional[float] = None,\n):\n    \"\"\"Initialize the camera test suite.\n\n    Args:\n        data_stream: The Camera data stream to test.\n        expected_fps: Optional expected frames per second for validation.\n        clock_jitter_s: Maximum allowed time difference between frame timestamps, in seconds.\n        start_time_s: Optional expected start time for validation, in seconds.\n        stop_time_s: Optional expected stop time for validation, in seconds.\n    \"\"\"\n    self.data_stream: Camera = data_stream\n    self.expected_fps = expected_fps\n    self.clock_jitter_s = clock_jitter_s\n    self.start_time_s = start_time_s\n    self.stop_time_s = stop_time_s\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_metadata_shape","title":"test_metadata_shape","text":"<pre><code>test_metadata_shape()\n</code></pre> <p>Checks if the metadata DataFrame has the expected shape. Including headers.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_metadata_shape(self):\n    \"\"\"\n    Checks if the metadata DataFrame has the expected shape. Including headers.\n    \"\"\"\n    if not self.data_stream.has_data:\n        return self.fail_test(None, \"Data stream does not have loaded data\")\n    metadata = self.data_stream.data.metadata\n    if not isinstance(metadata, pd.DataFrame):\n        return self.fail_test(None, \"Metadata is not a pandas DataFrame\")\n\n    (metadata_cols := list(metadata.columns)).append(metadata.index.name)\n    if not all(col in metadata_cols for col in self._expected_columns):\n        missing_columns = self._expected_columns - set(metadata_cols)\n        return self.fail_test(None, f\"Metadata columns do not match expected columns. Missing: {missing_columns}\")\n    if metadata.empty:\n        return self.fail_test(None, \"Metadata DataFrame is empty\")\n    return self.pass_test(None, \"Metadata DataFrame has expected shape and columns\")\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_check_dropped_frames","title":"test_check_dropped_frames","text":"<pre><code>test_check_dropped_frames()\n</code></pre> <p>Check if there are dropped frames in the metadata DataFrame.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_check_dropped_frames(self):\n    \"\"\"\n    Check if there are dropped frames in the metadata DataFrame.\n    \"\"\"\n    metadata = (self.data_stream.data.metadata[list(self._expected_columns - {\"ReferenceTime\"})]).copy()\n    metadata.loc[:, \"ReferenceTime\"] = metadata.index.values\n    diff_metadata = metadata.diff()\n    # Convert CameraFrameTime to seconds\n    diff_metadata[\"CameraFrameTime\"] = diff_metadata[\"CameraFrameTime\"] * 1e-9\n\n    if not all(diff_metadata[\"CameraFrameNumber\"].dropna() == 1):\n        return self.fail_test(\n            None, f\"Detected {sum(diff_metadata['CameraFrameNumber'].dropna() - 1)} dropped frames metadata.\"\n        )\n\n    inter_clock_diff = diff_metadata[\"CameraFrameTime\"] - diff_metadata[\"ReferenceTime\"]\n    if not all(inter_clock_diff.dropna() &lt; self.clock_jitter_s):\n        return self.fail_test(\n            None,\n            f\"Detected a difference between CameraFrameTime and ReferenceTime greater than the expected threshold: {self.clock_jitter_s} s.\",\n        )\n    return self.pass_test(None, \"No dropped frames detected in metadata.\")\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_match_expected_fps","title":"test_match_expected_fps","text":"<pre><code>test_match_expected_fps()\n</code></pre> <p>Check if the frames per second (FPS) of the video metadata matches the expected FPS.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_match_expected_fps(self):\n    \"\"\"\n    Check if the frames per second (FPS) of the video metadata matches the expected FPS.\"\"\"\n    if self.expected_fps is None:\n        return self.skip_test(\"No expected FPS provided, skipping test.\")\n    period = np.diff(self.data_stream.data.metadata.index.values)\n    if np.std(period) &gt; 1e-4:\n        return self.fail_test(None, f\"High std in frame period detected: {np.std(period)}\")\n    if abs(_mean := np.mean(period) - (_expected := (1.0 / self.expected_fps))) &gt; (_expected * 0.01):\n        return self.fail_test(None, f\"Mean frame period ({_mean}) is different than expected: {_expected}\")\n\n    return self.pass_test(None, f\"Mean frame period ({_mean}) is within expected range: {_expected}\")\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_is_start_bounded","title":"test_is_start_bounded","text":"<pre><code>test_is_start_bounded()\n</code></pre> <p>Check if the start time of the video is bounded by the provided start time.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_is_start_bounded(self):\n    \"\"\"\n    Check if the start time of the video is bounded by the provided start time.\"\"\"\n    metadata = self.data_stream.data.metadata\n    if self.start_time_s is not None:\n        if metadata.index[0] &lt; self.start_time_s:\n            return self.fail_test(\n                None,\n                f\"Start time is not bounded. First frame time: {metadata.index[0]}, expected start time: {self.start_time_s}\",\n            )\n        else:\n            return self.pass_test(\n                None,\n                f\"Start time is bounded. First frame time: {metadata.index[0]}, expected start time: {self.start_time_s}\",\n            )\n    else:\n        return self.skip_test(\"No start time provided, skipping test.\")\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_is_stop_bounded","title":"test_is_stop_bounded","text":"<pre><code>test_is_stop_bounded()\n</code></pre> <p>Check if the stop time of the video is bounded by the provided stop time.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_is_stop_bounded(self):\n    \"\"\"\n    Check if the stop time of the video is bounded by the provided stop time.\"\"\"\n    metadata = self.data_stream.data.metadata\n    if self.stop_time_s is not None:\n        if metadata.index[-1] &gt; self.stop_time_s:\n            return self.fail_test(\n                None,\n                f\"Stop time is not bounded. Last frame time: {metadata.index[-1]}, expected stop time: {self.stop_time_s}\",\n            )\n        else:\n            return self.pass_test(\n                None,\n                f\"Stop time is bounded. Last frame time: {metadata.index[-1]}, expected stop time: {self.stop_time_s}\",\n            )\n    else:\n        return self.skip_test(\"No stop time provided, skipping test.\")\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_video_frame_count","title":"test_video_frame_count","text":"<pre><code>test_video_frame_count()\n</code></pre> <p>Check if the number of frames in the video matches the number of rows in the metadata DataFrame.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_video_frame_count(self):\n    \"\"\"\n    Check if the number of frames in the video matches the number of rows in the metadata DataFrame.\n    \"\"\"\n    data = self.data_stream.data\n    if not data.has_video:\n        return self.skip_test(\"No video data available. Skipping test.\")\n\n    if (n_frames := data.video_frame_count) != len(data.metadata):\n        return self.fail_test(\n            None,\n            f\"Number of frames in video ({n_frames}) does not match number of rows in metadata ({len(data.metadata)})\",\n        )\n    else:\n        return self.pass_test(\n            None,\n            f\"Number of frames in video ({n_frames}) matches number of rows in metadata ({len(data.metadata)})\",\n        )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.test_histogram_and_create_asset","title":"test_histogram_and_create_asset","text":"<pre><code>test_histogram_and_create_asset()\n</code></pre> <p>Checks the histogram of the video and ensures color is well distributed. It also saves an asset with a single frame of the video and color histogram.</p> Source code in <code>src/contraqctor/qc/camera.py</code> <pre><code>def test_histogram_and_create_asset(self):\n    \"\"\"Checks the histogram of the video and ensures color is well distributed.\n    It also saves an asset with a single frame of the video and color histogram.\"\"\"\n\n    data = self.data_stream.data\n    if not data.has_video:\n        return self.skip_test(\"No video data available. Skipping test.\")\n\n    with data.as_video_capture() as video:\n        video.set(cv2.CAP_PROP_POS_FRAMES, video.get(cv2.CAP_PROP_FRAME_COUNT) // 2)\n        ret, frame = video.read()\n\n        if not ret:\n            return self.fail_test(None, \"Failed to read a frame from the video\")\n        max_d = 2 ** (frame.dtype.itemsize * 8)\n\n        if frame.shape[2] == 1:\n            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2RGB)\n        elif frame.shape[2] == 3:\n            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        else:\n            return self.fail_test(None, f\"Frame has unexpected number of channels({frame.shape[2]}).\")\n\n        hist_r = cv2.calcHist([frame], [0], None, [max_d], [0, max_d])\n        hist_g = cv2.calcHist([frame], [1], None, [max_d], [0, max_d])\n        hist_b = cv2.calcHist([frame], [2], None, [max_d], [0, max_d])\n\n        hist_r /= hist_r.sum()\n        hist_g /= hist_g.sum()\n        hist_b /= hist_b.sum()\n\n        fig, ax = plt.subplots(1, 2, figsize=(15, 5))\n\n        ax[0].imshow(frame)\n        ax[0].axis(\"off\")\n        ax[0].set_title(\"Frame from video\")\n        ax[1].plot(hist_r, color=\"red\", label=\"Red\")\n        ax[1].plot(hist_g, color=\"green\", label=\"Green\")\n        ax[1].plot(hist_b, color=\"blue\", label=\"Blue\")\n        ax[1].set_xlim([0, max_d])\n        ax[1].set_xlabel(\"Pixel Value\")\n        ax[1].set_ylabel(\"Normalized Frequency\")\n        ax[1].set_title(\"Color Histogram\")\n        ax[1].legend()\n        fig.tight_layout()\n\n        return self.pass_test(\n            None, \"Histogram and asset created successfully.\", context=ContextExportableObj.as_context(fig)\n        )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/camera/#contraqctor.qc.camera.CameraTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/contract/","title":"qc.contract","text":""},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite","title":"ContractTestSuite","text":"<pre><code>ContractTestSuite(\n    loading_errors: list[tuple[DataStream, Exception]],\n    exclude: Optional[list[DataStream]] = None,\n)\n</code></pre> <p>               Bases: <code>Suite</code></p> <p>Test suite for validating data stream loading.</p> <p>Converts the output of DataStream.load_all() into a test suite that can report on loading errors and distinguish between true errors and expected/excluded issues.</p> <p>Attributes:</p> Name Type Description <code>loading_errors</code> <p>List of tuples containing the data stream and the exception that occurred.</p> <code>exclude</code> <p>Optional list of data streams to exclude from error reporting.</p> <p>Examples:</p> <pre><code>from contraqctor.contract import Dataset\nfrom contraqctor.qc.contract import ContractTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create and attempt to load a dataset\ndataset = create_complex_dataset()\nloading_errors = dataset.load_all(strict=False)\n\n# Create test suite to analyze loading errors\nsuite = ContractTestSuite(\n    loading_errors,\n    exclude=[dataset[\"optional_stream\"]]  # Exclude known problematic stream\n)\n\n# Run tests\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the contract test suite.</p> <p>Parameters:</p> Name Type Description Default <code>loading_errors</code> <code>list[tuple[DataStream, Exception]]</code> <p>List of tuples containing data streams and their loading errors.</p> required <code>exclude</code> <code>Optional[list[DataStream]]</code> <p>Optional list of data streams to exclude from error reporting. These will be reported as warnings instead of failures.</p> <code>None</code> Source code in <code>src/contraqctor/qc/contract.py</code> <pre><code>def __init__(\n    self, loading_errors: list[tuple[DataStream, Exception]], exclude: t.Optional[list[DataStream]] = None\n):\n    \"\"\"Initialize the contract test suite.\n\n    Args:\n        loading_errors: List of tuples containing data streams and their loading errors.\n        exclude: Optional list of data streams to exclude from error reporting.\n            These will be reported as warnings instead of failures.\n    \"\"\"\n    self.loading_errors = loading_errors\n    self.exclude = exclude if exclude is not None else []\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.test_has_errors_on_load","title":"test_has_errors_on_load","text":"<pre><code>test_has_errors_on_load()\n</code></pre> <p>Check if any non-excluded data streams had loading errors.</p> Source code in <code>src/contraqctor/qc/contract.py</code> <pre><code>def test_has_errors_on_load(self):\n    \"\"\"Check if any non-excluded data streams had loading errors.\"\"\"\n    errors = [(ds, err) for ds, err in self.loading_errors if ds not in self.exclude]\n    if errors:\n        str_errors = \"\\n\".join([f\"{ds.resolved_name}\" for ds, _ in errors])\n        return self.fail_test(\n            None,\n            f\"The following DataStreams raised errors on load: \\n {str_errors}\",\n            context={\"errors\": errors},\n        )\n    else:\n        return self.pass_test(None, \"All DataStreams loaded successfully\")\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.test_has_excluded_as_warnings","title":"test_has_excluded_as_warnings","text":"<pre><code>test_has_excluded_as_warnings()\n</code></pre> <p>Check if any excluded data streams had loading errors and report as warnings.</p> Source code in <code>src/contraqctor/qc/contract.py</code> <pre><code>def test_has_excluded_as_warnings(self):\n    \"\"\"Check if any excluded data streams had loading errors and report as warnings.\"\"\"\n    warnings = [(ds, err) for ds, err in self.loading_errors if ds in self.exclude]\n    if warnings:\n        return self.warn_test(\n            None,\n            f\"Found {len(warnings)} DataStreams that raised ignored errors on load.\",\n            context={\"warnings\": warnings},\n        )\n    else:\n        return self.pass_test(None, \"No excluded DataStreams raised errors on load\")\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/contract/#contraqctor.qc.contract.ContractTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/core/","title":"qc","text":""},{"location":"api/qc/core/#contraqctor.qc.ContextExportableObj","title":"ContextExportableObj","text":"<pre><code>ContextExportableObj(obj: TExportable)\n</code></pre> <p>               Bases: <code>Generic[TExportable]</code></p> <p>Container for exportable objects in test contexts.</p> <p>Provides a standardized way to include exportable objects (like figures or reports) in test result contexts, allowing them to be properly handled by reporting tools.</p> <p>Attributes:</p> Name Type Description <code>_obj</code> <p>The exportable object being wrapped.</p> <p>Examples:</p> <pre><code>import matplotlib.pyplot as plt\nfrom contraqctor.qc._context_extensions import ContextExportableObj\nfrom contraqctor.qc.base import Suite\n\nclass VisualizationTestSuite(Suite):\n    def test_create_plot(self):\n        # Create a matplotlib figure\n        fig, ax = plt.subplots()\n        ax.plot([1, 2, 3], [4, 5, 6])\n        ax.set_title(\"Test Plot\")\n\n        # Add the figure to the test context\n        context = ContextExportableObj.as_context(fig)\n\n        # Return test result with the figure in context\n        return self.pass_test(True, \"Plot created successfully\", context=context)\n</code></pre> <p>Initialize the context exportable object container.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>TExportable</code> <p>The object to wrap for export.</p> required Source code in <code>src/contraqctor/qc/_context_extensions.py</code> <pre><code>def __init__(self, obj: TExportable) -&gt; None:\n    \"\"\"Initialize the context exportable object container.\n\n    Args:\n        obj: The object to wrap for export.\n    \"\"\"\n    self._obj = obj\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.ContextExportableObj.asset","title":"asset  <code>property</code>","text":"<pre><code>asset: TExportable\n</code></pre> <p>Get the wrapped exportable object.</p> <p>Returns:</p> Name Type Description <code>TExportable</code> <code>TExportable</code> <p>The wrapped object.</p>"},{"location":"api/qc/core/#contraqctor.qc.ContextExportableObj.asset_type","title":"asset_type  <code>property</code>","text":"<pre><code>asset_type: Type\n</code></pre> <p>Get the type of the wrapped asset.</p> <p>Returns:</p> Name Type Description <code>Type</code> <code>Type</code> <p>Type of the wrapped object.</p>"},{"location":"api/qc/core/#contraqctor.qc.ContextExportableObj.as_context","title":"as_context  <code>classmethod</code>","text":"<pre><code>as_context(\n    asset: TExportable,\n) -&gt; Dict[str, ContextExportableObj[TExportable]]\n</code></pre> <p>Create a standardized context dictionary for the exportable object.</p> <p>This method wraps the provided asset in a <code>ContextExportableObj</code> and includes it in a dictionary under a reserved keyword. This allows for consistent handling of exportable objects in test result contexts.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>TExportable</code> <p>The object to wrap and include in the context.</p> required <p>Returns:</p> Type Description <code>Dict[str, ContextExportableObj[TExportable]]</code> <p>Dict[str, ContextExportableObj]: A dictionary containing the wrapped</p> <code>Dict[str, ContextExportableObj[TExportable]]</code> <p>asset under the reserved key.</p> <p>Examples:</p> <pre><code>import matplotlib.pyplot as plt\nfrom contraqctor.qc._context_extensions import ContextExportableObj\n\n# Create a visualization\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], [4, 5, 6])\n\n# Create a context dictionary with the figure\ncontext = ContextExportableObj.as_context(fig)\n\n# The context can now be passed to test result methods\nreturn self.pass_test(True, \"Analysis succeeded\", context=context)\n</code></pre> Source code in <code>src/contraqctor/qc/_context_extensions.py</code> <pre><code>@classmethod\ndef as_context(self, asset: TExportable) -&gt; t.Dict[str, \"ContextExportableObj[TExportable]\"]:\n    \"\"\"Create a standardized context dictionary for the exportable object.\n\n    This method wraps the provided asset in a `ContextExportableObj` and\n    includes it in a dictionary under a reserved keyword. This allows for\n    consistent handling of exportable objects in test result contexts.\n\n    Args:\n        asset: The object to wrap and include in the context.\n\n    Returns:\n        Dict[str, ContextExportableObj]: A dictionary containing the wrapped\n        asset under the reserved key.\n\n    Examples:\n        ```python\n        import matplotlib.pyplot as plt\n        from contraqctor.qc._context_extensions import ContextExportableObj\n\n        # Create a visualization\n        fig, ax = plt.subplots()\n        ax.plot([1, 2, 3], [4, 5, 6])\n\n        # Create a context dictionary with the figure\n        context = ContextExportableObj.as_context(fig)\n\n        # The context can now be passed to test result methods\n        return self.pass_test(True, \"Analysis succeeded\", context=context)\n        ```\n    \"\"\"\n    return {ASSET_RESERVED_KEYWORD: ContextExportableObj(asset)}\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(\n    status: Status,\n    result: TResult,\n    test_name: str,\n    suite_name: str,\n    message: Optional[str] = None,\n    context: Optional[Any] = None,\n    description: Optional[str] = None,\n    exception: Optional[Exception] = None,\n    traceback: Optional[str] = None,\n    test_reference: Optional[ITest] = None,\n    suite_reference: Optional[Suite] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[TResult]</code></p> <p>Container for test execution results.</p> <p>Stores the outcome of a test execution including status, returned value, contextual information, and any exception details.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>Status</code> <p>The status of the test execution.</p> <code>result</code> <code>TResult</code> <p>The value returned by the test.</p> <code>test_name</code> <code>str</code> <p>Name of the test that generated this result.</p> <code>suite_name</code> <code>str</code> <p>Name of the test suite containing the test.</p> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the test outcome.</p> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>description</code> <code>Optional[str]</code> <p>Optional description of the test.</p> <code>exception</code> <code>Optional[Exception]</code> <p>Optional exception that occurred during test execution.</p> <code>traceback</code> <code>Optional[str]</code> <p>Optional traceback string if an exception occurred.</p> <code>test_reference</code> <code>Optional[ITest]</code> <p>Optional reference to the test function.</p> <code>suite_reference</code> <code>Optional[Suite]</code> <p>Optional reference to the suite that ran this test.</p>"},{"location":"api/qc/core/#contraqctor.qc.ResultsStatistics","title":"ResultsStatistics  <code>dataclass</code>","text":"<pre><code>ResultsStatistics(\n    passed: int,\n    failed: int,\n    error: int,\n    skipped: int,\n    warnings: int,\n)\n</code></pre> <p>Statistics about test results.</p> <p>Aggregates counts of test results by status and provides methods for calculating statistics like pass rate.</p> <p>Attributes:</p> Name Type Description <code>passed</code> <code>int</code> <p>Number of passed tests.</p> <code>failed</code> <code>int</code> <p>Number of failed tests.</p> <code>error</code> <code>int</code> <p>Number of tests that produced errors.</p> <code>skipped</code> <code>int</code> <p>Number of skipped tests.</p> <code>warnings</code> <code>int</code> <p>Number of tests with warnings.</p>"},{"location":"api/qc/core/#contraqctor.qc.ResultsStatistics.total","title":"total  <code>property</code>","text":"<pre><code>total: int\n</code></pre> <p>Get the total number of tests.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sum of all test result counts.</p>"},{"location":"api/qc/core/#contraqctor.qc.ResultsStatistics.pass_rate","title":"pass_rate  <code>property</code>","text":"<pre><code>pass_rate: float\n</code></pre> <p>Calculate the pass rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ratio of passed tests to total tests, or 0 if no tests.</p>"},{"location":"api/qc/core/#contraqctor.qc.ResultsStatistics.get_status_summary","title":"get_status_summary","text":"<pre><code>get_status_summary() -&gt; str\n</code></pre> <p>Generate a compact string summary of result counts.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Summary string with counts for each status type.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_status_summary(self) -&gt; str:\n    \"\"\"Generate a compact string summary of result counts.\n\n    Returns:\n        str: Summary string with counts for each status type.\n    \"\"\"\n    return f\"P:{self[Status.PASSED]} F:{self[Status.FAILED]} E:{self[Status.ERROR]} S:{self[Status.SKIPPED]} W:{self[Status.WARNING]}\"\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.ResultsStatistics.from_results","title":"from_results  <code>classmethod</code>","text":"<pre><code>from_results(results: List[Result]) -&gt; ResultsStatistics\n</code></pre> <p>Create statistics from a list of test results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Result]</code> <p>List of test results to analyze.</p> required <p>Returns:</p> Name Type Description <code>ResultsStatistics</code> <code>ResultsStatistics</code> <p>Statistics object summarizing the results.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@classmethod\ndef from_results(cls, results: t.List[Result]) -&gt; \"ResultsStatistics\":\n    \"\"\"Create statistics from a list of test results.\n\n    Args:\n        results: List of test results to analyze.\n\n    Returns:\n        ResultsStatistics: Statistics object summarizing the results.\n    \"\"\"\n    stats = {status: sum(1 for r in results if r.status == status) for status in Status}\n    return cls(\n        passed=stats[Status.PASSED],\n        failed=stats[Status.FAILED],\n        error=stats[Status.ERROR],\n        skipped=stats[Status.SKIPPED],\n        warnings=stats[Status.WARNING],\n    )\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Runner","title":"Runner","text":"<pre><code>Runner()\n</code></pre> <p>Test runner for executing suites and reporting results.</p> <p>Handles executing test suites, collecting results, and generating reports.</p> <p>Attributes:</p> Name Type Description <code>suites</code> <code>Dict[Optional[str], List[Suite]]</code> <p>Dictionary mapping group names to lists of test suites.</p> <code>_results</code> <code>Optional[List[_TaggedResult]]</code> <p>Optional dictionary of collected test results by group.</p> <p>Examples:</p> <pre><code>from contraqctor.qc.base import Runner\n\n# Create test suites\nsuite1 = MyTestSuite(component1)\nsuite2 = AnotherTestSuite(component2)\nsuite3 = YetAnotherTestSuite(component2)\n\n# Create runner and add suites with group names\nrunner = Runner()\nrunner.add_suite(suite1, \"Component Tests\")\nrunner.add_suite(suite2, \"Integration Tests\")\nrunner.add_suite(suite3, \"Integration Tests\")\n\n# Run all tests with progress display\nresults = runner.run_all_with_progress()\n\n# Access results by group\ncomponent_results = results[\"Component Tests\"]\n</code></pre> <p>Initialize the test runner.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the test runner.\"\"\"\n    self.suites: t.Dict[t.Optional[str], t.List[Suite]] = {}\n    self._results: t.Optional[t.List[_TaggedResult]] = None\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Runner.add_suite","title":"add_suite","text":"<pre><code>add_suite(suite: Suite) -&gt; Self\n</code></pre><pre><code>add_suite(suite: Suite, group: str) -&gt; Self\n</code></pre> <pre><code>add_suite(\n    suite: Suite, group: Optional[str] = None\n) -&gt; Self\n</code></pre> <p>Add a test suite to the runner.</p> <p>Parameters:</p> Name Type Description Default <code>suite</code> <code>Suite</code> <p>Test suite to add.</p> required <code>group</code> <code>Optional[str]</code> <p>Optional group name for organizing suites. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Runner</code> <code>Self</code> <p>Self for method chaining.</p> <p>Examples:</p> <pre><code>runner = Runner()\n\n# Add a suite without a group\nrunner.add_suite(BasicSuite())\n\n# Add suites with named groups for organization\nrunner.add_suite(DataSuite(), \"Data Validation\")\nrunner.add_suite(VisualizationSuite(), \"Data Validation\")\nrunner.add_suite(ApiSuite(), \"API Tests\")\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def add_suite(self, suite: Suite, group: t.Optional[str] = None) -&gt; t.Self:\n    \"\"\"Add a test suite to the runner.\n\n    Args:\n        suite: Test suite to add.\n        group: Optional group name for organizing suites. Defaults to None.\n\n    Returns:\n        Runner: Self for method chaining.\n\n    Examples:\n        ```python\n        runner = Runner()\n\n        # Add a suite without a group\n        runner.add_suite(BasicSuite())\n\n        # Add suites with named groups for organization\n        runner.add_suite(DataSuite(), \"Data Validation\")\n        runner.add_suite(VisualizationSuite(), \"Data Validation\")\n        runner.add_suite(ApiSuite(), \"API Tests\")\n        ```\n    \"\"\"\n    self._update_suites(suite, group)\n    return self\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Runner.run_all_with_progress","title":"run_all_with_progress","text":"<pre><code>run_all_with_progress(\n    *,\n    render_context: bool = True,\n    render_description: bool = True,\n    render_traceback: bool = True,\n    render_message: bool = True,\n) -&gt; Dict[Optional[str], List[Result]]\n</code></pre> <p>Run all tests in all suites with a rich progress display.</p> <p>Executes all tests with a visual progress bar and detailed reporting of test outcomes.</p> <p>Parameters:</p> Name Type Description Default <code>render_context</code> <code>bool</code> <p>Whether to render test context in result output.</p> <code>True</code> <code>render_description</code> <code>bool</code> <p>Whether to render test descriptions in result output.</p> <code>True</code> <code>render_traceback</code> <code>bool</code> <p>Whether to render tracebacks for errors in result output.</p> <code>True</code> <code>render_message</code> <code>bool</code> <p>Whether to render test result messages in result output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[Optional[str], List[Result]]</code> <p>Dict[Optional[str], List[Result]]: Results grouped by test group name.</p> <p>Examples:</p> <pre><code>runner = Runner()\nrunner.add_suite(DataValidationSuite(), \"Validation\")\nrunner.add_suite(PerformanceSuite(), \"Performance\")\n\n# Run all tests with progress display and complete output\nresults = runner.run_all_with_progress()\n\n# Run with simplified output (no context or traceback)\nresults = runner.run_all_with_progress(\n    render_context=False,\n    render_traceback=False\n)\n\n# Check if any tests failed\nall_passed = all(\n    result.status == Status.PASSED\n    for group_results in results.values()\n    for result in group_results\n)\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all_with_progress(\n    self,\n    *,\n    render_context: bool = True,\n    render_description: bool = True,\n    render_traceback: bool = True,\n    render_message: bool = True,\n) -&gt; t.Dict[t.Optional[str], t.List[Result]]:\n    \"\"\"Run all tests in all suites with a rich progress display.\n\n    Executes all tests with a visual progress bar and detailed reporting\n    of test outcomes.\n\n    Args:\n        render_context: Whether to render test context in result output.\n        render_description: Whether to render test descriptions in result output.\n        render_traceback: Whether to render tracebacks for errors in result output.\n        render_message: Whether to render test result messages in result output.\n\n    Returns:\n        Dict[Optional[str], List[Result]]: Results grouped by test group name.\n\n    Examples:\n        ```python\n        runner = Runner()\n        runner.add_suite(DataValidationSuite(), \"Validation\")\n        runner.add_suite(PerformanceSuite(), \"Performance\")\n\n        # Run all tests with progress display and complete output\n        results = runner.run_all_with_progress()\n\n        # Run with simplified output (no context or traceback)\n        results = runner.run_all_with_progress(\n            render_context=False,\n            render_traceback=False\n        )\n\n        # Check if any tests failed\n        all_passed = all(\n            result.status == Status.PASSED\n            for group_results in results.values()\n            for result in group_results\n        )\n        ```\n    \"\"\"\n\n    collected_tests = self._collect_tests()\n    total_test_count = len(collected_tests)\n\n    suite_name_lengths = [len(suite.name) for suite, _ in _TaggedTest.group_by_suite(collected_tests)]\n    # we sum 2 to account for brackets\n    group_lengths = [\n        len(group) + 2 for group, _ in _TaggedTest.group_by_group(collected_tests) if group is not None\n    ]\n    full_name_width = max(suite_name_lengths + group_lengths) if suite_name_lengths else 10\n    test_name_width = 20  # To render the test name during progress\n    bar_width = 20\n\n    progress_format = [\n        f\"[progress.description]{{task.description:&lt;{full_name_width + test_name_width + 5}}}\",\n        rich.progress.BarColumn(),\n        \"[progress.percentage]{task.percentage:&gt;3.0f}%\",\n        \"\u2022\",\n        rich.progress.TimeElapsedColumn(),\n    ]\n\n    with rich.progress.Progress(*progress_format) as progress:\n        total_task = progress.add_task(\n            \"[bold green]TOTAL PROGRESS\".ljust(full_name_width + test_name_width + 5), total=total_test_count\n        )\n\n        collected_results: t.List[_TaggedResult] = []\n        for group, tests_in_group in _TaggedTest.group_by_group(collected_tests):\n            _title = (\n                rich.markup.escape(f\"[{group}]\") if group else rich.markup.escape(f\"[{self._DEFAULT_TEST_GROUP}]\")\n            )\n            group_task = progress.add_task(\n                f\"[honeydew2]{_title}\".ljust(full_name_width + test_name_width + 5),\n                total=len(tests_in_group),\n            )\n            for suite, tests_in_suite in _TaggedTest.group_by_suite(tests_in_group):\n                results = self._run_suite_tests(\n                    progress,\n                    suite,\n                    [t.test for t in tests_in_suite],\n                    full_name_width,\n                    test_name_width,\n                    total_task,\n                    group_task,\n                )\n                for result in results:\n                    collected_results.append(\n                        _TaggedResult(suite=suite, group=group, result=result, test=result.test_reference)\n                    )\n\n            if len(_TaggedResult.get_by_group(collected_results, group)) &gt; 0:\n                group_results = [\n                    tagged_result.result for tagged_result in _TaggedResult.get_by_group(collected_results, group)\n                ]\n                group_stats = ResultsStatistics.from_results(group_results)\n                group_status_bar = self._render_status_bar(group_stats, bar_width)\n                padding_width = max(0, full_name_width - len(self._rich_unscape(_title)))\n                group_line = f\"[honeydew2]{_title}{' ' * padding_width} | {group_status_bar} | {group_stats.get_status_summary()}\"\n                progress.update(group_task, description=group_line)\n\n        if total_test_count &gt; 0:\n            total_stats = ResultsStatistics.from_results(\n                [tagged_result.result for tagged_result in collected_results]\n            )\n            total_status_bar = self._render_status_bar(total_stats, bar_width)\n\n            _title = \"TOTAL PROGRESS\"\n            # Fix: Use max() to ensure padding width is never negative\n            padding_width = max(0, full_name_width - len(_title))\n            total_line = f\"[bold green]{_title}{' ' * padding_width} | {total_status_bar} | {total_stats.get_status_summary()}\"\n            progress.update(total_task, description=total_line)\n\n    self._results = collected_results\n    if self._results:\n        self._print_results(\n            self._results,\n            render_description=render_description,\n            render_traceback=render_traceback,\n            render_message=render_message,\n            render_context=render_context,\n        )\n\n    out: t.Dict[t.Optional[str], t.List[Result]] = {}\n    for group, grouped_results in _TaggedResult.group_by_group(collected_results):\n        out[group] = [tagged_result.result for tagged_result in grouped_results]\n    return out\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing possible test result statuses.</p> <p>Defines the different states a test can be in after execution.</p>"},{"location":"api/qc/core/#contraqctor.qc.Suite","title":"Suite","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for test suites.</p> <p>Provides the core functionality for defining, running, and reporting on tests. All test suites should inherit from this class and implement test methods that start with 'test'.</p> <p>Examples:</p> <pre><code>from contraqctor.qc.base import Suite\n\nclass MyTestSuite(Suite):\n    \"\"\"Test suite for validating my component.\"\"\"\n\n    def __init__(self, component):\n        self.component = component\n\n    def test_has_required_property(self):\n        if hasattr(self.component, \"required_property\"):\n            return self.pass_test(True, \"Component has required property\")\n        else:\n            return self.fail_test(False, \"Component is missing required property\")\n\n    def test_performs_calculation(self):\n        try:\n            result = self.component.calculate(10)\n            if result == 20:\n                return self.pass_test(result, \"Calculation correct\")\n            else:\n                return self.fail_test(result, f\"Expected 20 but got {result}\")\n        except Exception as e:\n            return self.fail_test(None, f\"Calculation failed: {str(e)}\")\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/core/#contraqctor.qc.Suite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/core/#contraqctor.qc.Suite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.Suite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.allow_null_as_pass","title":"allow_null_as_pass","text":"<pre><code>allow_null_as_pass(value: bool = True)\n</code></pre> <p>Context manager to control whether null results are allowed as pass.</p> <p>When enabled, tests that return None will be treated as passing tests rather than producing errors.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to allow null results as passing, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import allow_null_as_pass, Runner\n\n# Create a test suite with methods that return None\nclass SimpleTestSuite(Suite):\n    def test_basic_check(self):\n        # This method returns None, which would normally be an error\n        print(\"Performing a check\")\n        # No explicit return\n\n# Run with allow_null_as_pass to treat None returns as passing\nsuite = SimpleTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith allow_null_as_pass():\n    # None returns will be treated as passing tests\n    results = runner.run_all_with_progress()\n\n# Outside the context manager, None returns would cause errors\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef allow_null_as_pass(value: bool = True):\n    \"\"\"Context manager to control whether null results are allowed as pass.\n\n    When enabled, tests that return None will be treated as passing tests\n    rather than producing errors.\n\n    Args:\n        value: True to allow null results as passing, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import allow_null_as_pass, Runner\n\n        # Create a test suite with methods that return None\n        class SimpleTestSuite(Suite):\n            def test_basic_check(self):\n                # This method returns None, which would normally be an error\n                print(\"Performing a check\")\n                # No explicit return\n\n        # Run with allow_null_as_pass to treat None returns as passing\n        suite = SimpleTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with allow_null_as_pass():\n            # None returns will be treated as passing tests\n            results = runner.run_all_with_progress()\n\n        # Outside the context manager, None returns would cause errors\n        ```\n    \"\"\"\n    token = _allow_null_as_pass_ctx.set(value)\n    try:\n        yield\n    finally:\n        _allow_null_as_pass_ctx.reset(token)\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.elevated_skips","title":"elevated_skips","text":"<pre><code>elevated_skips(value: bool = True)\n</code></pre> <p>Context manager to control whether skipped tests are treated as failures.</p> <p>When enabled, skipped tests will be treated as failing tests rather than being merely marked as skipped.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to elevate skipped tests to failures, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import elevated_skips, Runner\n\n# Create a test suite with some skipped tests\nclass FeatureTestSuite(Suite):\n    def test_implemented_feature(self):\n        return self.pass_test(True, \"Feature works\")\n\n    def test_unimplemented_feature(self):\n        return self.skip_test(\"Feature not yet implemented\")\n\n# Run with elevated_skips to fail when tests are skipped\nsuite = FeatureTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith elevated_skips():\n    # Skipped tests will be treated as failures\n    results = runner.run_all_with_progress()\n\n# Without the context manager, skips are just marked as skipped\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef elevated_skips(value: bool = True):\n    \"\"\"Context manager to control whether skipped tests are treated as failures.\n\n    When enabled, skipped tests will be treated as failing tests rather than\n    being merely marked as skipped.\n\n    Args:\n        value: True to elevate skipped tests to failures, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import elevated_skips, Runner\n\n        # Create a test suite with some skipped tests\n        class FeatureTestSuite(Suite):\n            def test_implemented_feature(self):\n                return self.pass_test(True, \"Feature works\")\n\n            def test_unimplemented_feature(self):\n                return self.skip_test(\"Feature not yet implemented\")\n\n        # Run with elevated_skips to fail when tests are skipped\n        suite = FeatureTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with elevated_skips():\n            # Skipped tests will be treated as failures\n            results = runner.run_all_with_progress()\n\n        # Without the context manager, skips are just marked as skipped\n        ```\n    \"\"\"\n    token = _elevate_skippable.set(value)\n    try:\n        yield\n    finally:\n        _elevate_skippable.reset(token)\n</code></pre>"},{"location":"api/qc/core/#contraqctor.qc.elevated_warnings","title":"elevated_warnings","text":"<pre><code>elevated_warnings(value: bool = True)\n</code></pre> <p>Context manager to control whether warnings are treated as failures.</p> <p>When enabled, warning results will be treated as failing tests rather than just being marked as warnings.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True to elevate warnings to failures, False otherwise.</p> <code>True</code> <p>Examples:</p> <pre><code>from contraqctor.qc.base import elevated_warnings, Runner\n\n# Create a test suite with warning conditions\nclass PerformanceTestSuite(Suite):\n    def test_response_time(self):\n        response_time = measure_response()\n\n        if response_time &lt; 100:\n            return self.pass_test(response_time, \"Response time acceptable\")\n        elif response_time &lt; 200:\n            # This would normally be a warning\n            return self.warn_test(response_time, \"Response time degraded\")\n        else:\n            return self.fail_test(response_time, \"Response time unacceptable\")\n\n# Run with elevated_warnings to fail on warnings\nsuite = PerformanceTestSuite()\nrunner = Runner().add_suite(suite)\n\nwith elevated_warnings():\n    # Warning results will be treated as failures\n    # Useful in CI/CD pipelines where warnings should trigger failures\n    results = runner.run_all_with_progress()\n</code></pre> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>@contextmanager\ndef elevated_warnings(value: bool = True):\n    \"\"\"Context manager to control whether warnings are treated as failures.\n\n    When enabled, warning results will be treated as failing tests rather than\n    just being marked as warnings.\n\n    Args:\n        value: True to elevate warnings to failures, False otherwise.\n\n    Examples:\n        ```python\n        from contraqctor.qc.base import elevated_warnings, Runner\n\n        # Create a test suite with warning conditions\n        class PerformanceTestSuite(Suite):\n            def test_response_time(self):\n                response_time = measure_response()\n\n                if response_time &lt; 100:\n                    return self.pass_test(response_time, \"Response time acceptable\")\n                elif response_time &lt; 200:\n                    # This would normally be a warning\n                    return self.warn_test(response_time, \"Response time degraded\")\n                else:\n                    return self.fail_test(response_time, \"Response time unacceptable\")\n\n        # Run with elevated_warnings to fail on warnings\n        suite = PerformanceTestSuite()\n        runner = Runner().add_suite(suite)\n\n        with elevated_warnings():\n            # Warning results will be treated as failures\n            # Useful in CI/CD pipelines where warnings should trigger failures\n            results = runner.run_all_with_progress()\n        ```\n    \"\"\"\n    token = _elevate_warning.set(value)\n    try:\n        yield\n    finally:\n        _elevate_warning.reset(token)\n</code></pre>"},{"location":"api/qc/csv/","title":"qc.csv","text":""},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite","title":"CsvTestSuite","text":"<pre><code>CsvTestSuite(data_stream: Csv)\n</code></pre> <p>               Bases: <code>Suite</code></p> <p>Test suite to check if CSV files generated are well formatted.</p> <p>Provides tests to validate that CSV files conform to expected formatting standards and contain valid data.</p> <p>Attributes:</p> Name Type Description <code>data_stream</code> <p>The CSV data stream to test.</p> <p>Examples:</p> <pre><code>from contraqctor.contract.csv import Csv, CsvParams\nfrom contraqctor.qc.csv import CsvTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create and load a CSV data stream\nparams = CsvParams(path=\"data/measurements.csv\")\ncsv_stream = Csv(\"measurements\", reader_params=params).load()\n\n# Create and run the test suite\nsuite = CsvTestSuite(csv_stream)\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the CSV test suite.</p> <p>Parameters:</p> Name Type Description Default <code>data_stream</code> <code>Csv</code> <p>The CSV data stream to test.</p> required Source code in <code>src/contraqctor/qc/csv.py</code> <pre><code>def __init__(self, data_stream: Csv):\n    \"\"\"Initialize the CSV test suite.\n\n    Args:\n        data_stream: The CSV data stream to test.\n    \"\"\"\n    self.data_stream = data_stream\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.test_is_instance_of_pandas_dataframe","title":"test_is_instance_of_pandas_dataframe","text":"<pre><code>test_is_instance_of_pandas_dataframe()\n</code></pre> <p>Check if the data stream is a pandas DataFrame.</p> Source code in <code>src/contraqctor/qc/csv.py</code> <pre><code>def test_is_instance_of_pandas_dataframe(self):\n    \"\"\"\n    Check if the data stream is a pandas DataFrame.\n    \"\"\"\n    if not self.data_stream.has_data:\n        return self.fail_test(None, \"Data stream does not have loaded data\")\n    if not isinstance(self.data_stream.data, pd.DataFrame):\n        return self.fail_test(None, \"Data stream is not a pandas DataFrame\")\n    return self.pass_test(None, \"Data stream is a pandas DataFrame\")\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.test_is_not_empty","title":"test_is_not_empty","text":"<pre><code>test_is_not_empty()\n</code></pre> <p>Check if the DataFrame is not empty.</p> Source code in <code>src/contraqctor/qc/csv.py</code> <pre><code>def test_is_not_empty(self):\n    \"\"\"\n    Check if the DataFrame is not empty.\n    \"\"\"\n    df = self.data_stream.data\n    if df.empty:\n        return self.fail_test(None, \"Data stream is empty\")\n    return self.pass_test(None, \"Data stream is not empty\")\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.test_infer_missing_headers","title":"test_infer_missing_headers","text":"<pre><code>test_infer_missing_headers()\n</code></pre> <p>Infer if the DataFrame was loaded from a CSV without headers.</p> Source code in <code>src/contraqctor/qc/csv.py</code> <pre><code>def test_infer_missing_headers(self):\n    \"\"\"\n    Infer if the DataFrame was loaded from a CSV without headers.\n    \"\"\"\n    if not self.data_stream.reader_params.strict_header:\n        return self.skip_test(\"CSV was loaded with strict_header=False\")\n\n    df = self.data_stream.data\n    if df.empty or len(df.columns) == 0:\n        return self.fail_test(None, \"Data stream is empty or has no columns\")\n\n    # Check if column names are default integer indexes (0, 1, 2...)\n    if all(isinstance(col, int) or (isinstance(col, str) and col.isdigit()) for col in df.columns):\n        return self.fail_test(None, \"Data stream has non-integer column names\")\n\n    return self.pass_test(None, \"DataFramed was likely loaded from a CSV with headers\")\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/csv/#contraqctor.qc.csv.CsvTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/harp/","title":"qc.harp","text":""},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite","title":"HarpDeviceTestSuite","text":"<pre><code>HarpDeviceTestSuite(\n    harp_device: HarpDevice,\n    harp_device_commands: Optional[HarpDevice] = None,\n    *,\n    min_core_version: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Suite</code></p> <p>Test suite for generic HARP devices.</p> <p>Provides a set of standard tests that all HARP devices are expected to pass, checking basic functionality and data integrity.</p> <p>Attributes:</p> Name Type Description <code>harp_device</code> <p>The HarpDevice data stream to test.</p> <code>harp_device_commands</code> <p>Optional HarpDevice data stream with device commands.</p> <code>min_core_version</code> <p>Optional minimum required core version.</p> <p>Examples:</p> <pre><code>from contraqctor.contract.harp import HarpDevice\nfrom contraqctor.qc.harp import HarpDeviceTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create HarpDevice streams\ndevice = HarpDevice(\"behavior\", reader_params=params).load()\ncommands = HarpDevice(\"behavior_commands\", reader_params=command_params).load()\n\n# Create and run test suite\nsuite = HarpDeviceTestSuite(device, commands, min_core_version=\"1.2.0\")\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the HARP device test suite.</p> <p>Parameters:</p> Name Type Description Default <code>harp_device</code> <code>HarpDevice</code> <p>The HarpDevice data stream to test.</p> required <code>harp_device_commands</code> <code>Optional[HarpDevice]</code> <p>Optional HarpDevice data stream with command history. If None, tests requiring the commands will be skipped.</p> <code>None</code> <code>min_core_version</code> <code>Optional[str]</code> <p>Optional minimum required core version for validation.</p> <code>None</code> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def __init__(\n    self,\n    harp_device: HarpDevice,\n    harp_device_commands: t.Optional[HarpDevice] = None,\n    *,\n    min_core_version: t.Optional[str] = None,\n):\n    \"\"\"Initialize the HARP device test suite.\n\n    Args:\n        harp_device: The HarpDevice data stream to test.\n        harp_device_commands: Optional HarpDevice data stream with command history.\n            If None, tests requiring the commands will be skipped.\n        min_core_version: Optional minimum required core version for validation.\n    \"\"\"\n    self.harp_device = harp_device\n    self.harp_device_commands = harp_device_commands\n    self.min_core_version = min_core_version\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_has_whoami","title":"test_has_whoami","text":"<pre><code>test_has_whoami()\n</code></pre> <p>Check if the harp board data stream is present and return its value</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_has_whoami(self):\n    \"\"\"Check if the harp board data stream is present and return its value\"\"\"\n    who_am_i_reg: HarpRegister = self.harp_device[\"WhoAmI\"]\n    if not who_am_i_reg.has_data:\n        return self.fail_test(None, \"WhoAmI does not have loaded data\")\n    if len(who_am_i_reg.data) == 0:\n        return self.fail_test(None, \"WhoAmI file is empty\")\n    who_am_i = self._get_whoami(self.harp_device)\n    if not bool(0000 &lt;= who_am_i &lt;= 9999):\n        return self.fail_test(who_am_i, \"WhoAmI value is not in the range 0000-9999\")\n    return self.pass_test(int(who_am_i))\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_match_whoami_to_yml","title":"test_match_whoami_to_yml","text":"<pre><code>test_match_whoami_to_yml()\n</code></pre> <p>Check if the WhoAmI value matches the device's WhoAmI</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_match_whoami_to_yml(self):\n    \"\"\"Check if the WhoAmI value matches the device's WhoAmI\"\"\"\n    if self._get_whoami(self.harp_device) == self.harp_device.device_reader.device.whoAmI:\n        return self.pass_test(True, \"WhoAmI value matches the device's WhoAmI\")\n    else:\n        return self.fail_test(False, \"WhoAmI value does not match the device's WhoAmI\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_read_dump_is_complete","title":"test_read_dump_is_complete","text":"<pre><code>test_read_dump_is_complete()\n</code></pre> <p>Check if the read dump from an harp device is complete</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_read_dump_is_complete(self):\n    \"\"\"\n    Check if the read dump from an harp device is complete\n    \"\"\"\n    expected_regs = self.harp_device.device_reader.device.registers.keys()\n    ds = [stream for stream in self.harp_device]\n    missing_regs = [reg_name for reg_name in expected_regs if reg_name not in [r.name for r in ds]]\n    if len(missing_regs) &gt; 0:\n        return self.fail_test(\n            False,\n            \"Read dump is not complete. Some registers are missing.\",\n            context={\"missing_registers\": missing_regs},\n        )\n    missing_read_dump = [\n        r.name for r in ds if not (r.name in expected_regs and (self._get_last_read(r) is not None))\n    ]\n    return (\n        self.pass_test(True, \"Read dump is complete\")\n        if len(missing_read_dump) == 0\n        else self.fail_test(False, \"Read dump is not complete\", context={\"missing_registers\": missing_read_dump})\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_request_response","title":"test_request_response","text":"<pre><code>test_request_response()\n</code></pre> <p>Check that each request to the device has a corresponding response</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_request_response(self):\n    \"\"\"Check that each request to the device has a corresponding response\"\"\"\n    if self.harp_device_commands is None:\n        return self.skip_test(\"No harp device commands provided\")\n\n    op_ctr: pd.DataFrame = self.harp_device_commands[\"OperationControl\"].data\n    op_ctr = op_ctr[op_ctr[\"MessageType\"] == \"WRITE\"]\n    op_ctr = op_ctr.index.values[0]\n\n    reg_error = []\n    for req_reg in self.harp_device_commands:\n        if req_reg.has_data:  # Only data streams with data can be checked\n            # Only \"Writes\" will be considered, but in theory we could also check \"Reads\"\n            requests: pd.DataFrame = req_reg.data[req_reg.data[\"MessageType\"] == \"WRITE\"]\n            rep_reg = self.harp_device[req_reg.name]\n            replies: pd.DataFrame = rep_reg.data[rep_reg.data[\"MessageType\"] == \"WRITE\"]\n\n            # All responses must, by definition, be timestamped AFTER the request\n            if len(requests) &gt; 0:\n                requests = requests[requests.index &gt;= op_ctr]\n                replies = replies[replies.index &gt;= op_ctr]\n                if len(requests) != len(replies):\n                    reg_error.append(\n                        {\"register\": req_reg.name, \"requests\": len(requests), \"responses\": len(replies)}\n                    )\n\n    if len(reg_error) == 0:\n        return self.pass_test(\n            None,\n            \"Request/Response check passed. All requests have a corresponding response.\",\n        )\n    else:\n        return self.fail_test(\n            None,\n            \"Request/Response check failed. Some requests do not have a corresponding response.\",\n            context={\"register_errors\": reg_error},\n        )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_registers_are_monotonicity","title":"test_registers_are_monotonicity","text":"<pre><code>test_registers_are_monotonicity()\n</code></pre> <p>Check that the all the harp device registers' timestamps are monotonic</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_registers_are_monotonicity(self):\n    \"\"\"\n    Check that the all the harp device registers' timestamps are monotonic\n    \"\"\"\n    reg_errors = []\n    reg: HarpRegister\n    for reg in self.harp_device:\n        for message_type, reg_type_data in reg.data.groupby(\"MessageType\", observed=True):\n            if not reg_type_data.index.is_monotonic_increasing:\n                reg_errors.append(\n                    {\n                        \"register\": reg.name,\n                        \"message_type\": message_type,\n                        \"is_monotonic\": reg.data.index.is_monotonic_increasing,\n                    }\n                )\n    if len(reg_errors) == 0:\n        return self.pass_test(\n            None,\n            \"Monotonicity check passed. All registers are monotonic.\",\n        )\n    else:\n        return self.fail_test(\n            None,\n            \"Monotonicity check failed. Some registers are not monotonic.\",\n            context={\"register_errors\": reg_errors},\n        )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_fw_version_matches_reader","title":"test_fw_version_matches_reader","text":"<pre><code>test_fw_version_matches_reader()\n</code></pre> <p>Check if the firmware version of the device matches the one in the reader</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_fw_version_matches_reader(self):\n    \"\"\"Check if the firmware version of the device matches the one in the reader\"\"\"\n    reader = self.harp_device.device_reader\n\n    fw = self._try_parse_semver(reader.device.firmwareVersion)\n    device_fw = self._try_parse_semver(\n        f\"{self._get_last_read(self.harp_device['FirmwareVersionHigh']).iloc[0]}.{self._get_last_read(self.harp_device['FirmwareVersionLow']).iloc[0]}\"\n    )\n\n    if (fw is None) or (device_fw is None):\n        return self.fail_test(\n            None, f\"Firmware version is not a valid semver version. Expected {fw} and got {device_fw}\"\n        )\n    if fw &gt; device_fw:\n        return self.fail_test(\n            False,\n            f\"Expected version {fw} is greater than the device's version {device_fw}. Consider updating the device firmware.\",\n        )\n    elif fw == device_fw:\n        return self.pass_test(True, f\"Expected version {fw} matches the device's version {device_fw}\")\n    else:\n        return self.warn_test(\n            False,\n            f\"Expected version {fw} is less than the device's version {device_fw}. Consider updating interface package.\",\n        )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.test_core_version","title":"test_core_version","text":"<pre><code>test_core_version()\n</code></pre> <p>Check if the core version of the device matches the one provided</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_core_version(self):\n    \"\"\"Check if the core version of the device matches the one provided\"\"\"\n    core = self._try_parse_semver(self.min_core_version) if self.min_core_version else None\n    device_core = self._try_parse_semver(\n        f\"{self._get_last_read(self.harp_device['CoreVersionHigh']).iloc[0]}.{self._get_last_read(self.harp_device['CoreVersionLow']).iloc[0]}\"\n    )\n\n    if core is None:\n        return self.skip_test(\"Core version not specified, skipping test.\")\n    if device_core is None:\n        return self.fail_test(\"Core version is not a valid semver version.\")\n\n    if core &gt; device_core:\n        return self.fail_test(\n            False,\n            f\"Core version {core} is greater than the device's version {device_core}. Consider updating the device firmware.\",\n        )\n    elif core == device_core:\n        return self.pass_test(True, f\"Core version {core} matches the device's version {device_core}\")\n    else:\n        return self.warn_test(False, f\"Core version {core} is less than the device's version {device_core}\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite","title":"HarpHubTestSuite","text":"<pre><code>HarpHubTestSuite(\n    clock_generator_device: HarpDevice,\n    devices: List[HarpDevice],\n    *,\n    read_dump_jitter_threshold_s: Optional[float] = 0.05,\n)\n</code></pre> <p>               Bases: <code>Suite</code></p> <p>Test suite for a hub of HARP devices.</p> <p>Tests a collection of HARP devices that share the same clock generator source, verifying proper synchronization and configuration.</p> <p>Attributes:</p> Name Type Description <code>clock_generator_device</code> <p>The HARP device acting as the clock generator.</p> <code>devices</code> <p>List of subordinate HARP devices to test.</p> <code>read_dump_jitter_threshold_s</code> <p>Maximum allowed time difference for read dumps.</p> <p>Examples:</p> <pre><code>from contraqctor.contract.harp import HarpDevice\nfrom contraqctor.qc.harp import HarpHubTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create HarpDevice streams\nclock_gen = HarpDevice(\"clock_gen\", reader_params=clock_params).load()\ndevice1 = HarpDevice(\"device1\", reader_params=params1).load()\ndevice2 = HarpDevice(\"device2\", reader_params=params2).load()\n\n# Create and run hub test suite\nsuite = HarpHubTestSuite(clock_gen, [device1, device2])\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the HARP hub test suite.</p> <p>Parameters:</p> Name Type Description Default <code>clock_generator_device</code> <code>HarpDevice</code> <p>The HARP device acting as the clock generator.</p> required <code>devices</code> <code>List[HarpDevice]</code> <p>List of HARP devices to test as part of the hub.</p> required <code>read_dump_jitter_threshold_s</code> <code>Optional[float]</code> <p>Maximum allowed time difference (in seconds) between devices' read dumps. Defaults to 0.05.</p> <code>0.05</code> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def __init__(\n    self,\n    clock_generator_device: HarpDevice,\n    devices: t.List[HarpDevice],\n    *,\n    read_dump_jitter_threshold_s: t.Optional[float] = 0.05,\n):\n    \"\"\"Initialize the HARP hub test suite.\n\n    Args:\n        clock_generator_device: The HARP device acting as the clock generator.\n        devices: List of HARP devices to test as part of the hub.\n        read_dump_jitter_threshold_s: Maximum allowed time difference (in seconds)\n            between devices' read dumps. Defaults to 0.05.\n    \"\"\"\n    self.clock_generator_device = clock_generator_device\n    self.devices = [device for device in devices if device is not clock_generator_device]\n    self.read_dump_jitter_threshold_s = read_dump_jitter_threshold_s\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.test_clock_generator_reg","title":"test_clock_generator_reg","text":"<pre><code>test_clock_generator_reg()\n</code></pre> <p>Checks if the clock generator device is actually a clock generator</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_clock_generator_reg(self):\n    \"\"\"Checks if the clock generator device is actually a clock generator\"\"\"\n    if \"ClockConfiguration\" not in [x.name for x in self.clock_generator_device]:\n        return self.fail_test(None, \"ClockConfiguration data stream is not present\")\n    clock_reg = self.clock_generator_device[\"ClockConfiguration\"].data.iloc[-1]\n    if clock_reg[\"ClockGenerator\"]:\n        return self.pass_test(True, \"Clock generator is a clock generator\")\n    else:\n        return self.fail_test(False, \"Clock generator is not a clock generator\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.test_devices_are_subordinate","title":"test_devices_are_subordinate","text":"<pre><code>test_devices_are_subordinate()\n</code></pre> <p>Checks if the devices are subordinate to the clock generator</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_devices_are_subordinate(self):\n    \"\"\"Checks if the devices are subordinate to the clock generator\"\"\"\n    for device in self.devices:\n        if \"ClockConfiguration\" not in [x.name for x in device]:\n            yield self.fail_test(None, f\"ClockConfiguration data stream is not present in {device.name}\")\n        elif device[\"ClockConfiguration\"].data.iloc[-1][\"ClockGenerator\"]:\n            yield self.fail_test(False, f\"Device {device.name} is not subordinate to the clock generator\")\n        else:\n            yield self.pass_test(True, f\"Device {device.name} is subordinate to the clock generator\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.test_is_read_dump_synchronized","title":"test_is_read_dump_synchronized","text":"<pre><code>test_is_read_dump_synchronized()\n</code></pre> <p>Check if the read dump from the devices arrives are roughly the same time</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_is_read_dump_synchronized(self):\n    \"\"\"Check if the read dump from the devices arrives are roughly the same time\"\"\"\n    if self.read_dump_jitter_threshold_s is None:\n        return self.skip_test(\"No read dump jitter threshold provided, skipping test.\")\n    clock_dump_time = self._get_read_dump_time(self.clock_generator_device)\n    for device in self.devices:\n        t_dump = self._get_read_dump_time(device)\n        if t_dump is None:\n            yield self.fail_test(None, f\"Device {device.name} does not have a requested read dump\")\n        elif (dt := abs(t_dump - clock_dump_time)) &gt; self.read_dump_jitter_threshold_s:\n            yield self.fail_test(\n                False,\n                f\"Device {device.name} read dump is not synchronized with the clock generator's. dt = {dt:.3f} s vs threshold {self.read_dump_jitter_threshold_s:.3f} s\",\n            )\n        else:\n            yield self.pass_test(True, f\"Device {device.name} read dump is synchronized with the clock generator's\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpHubTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite","title":"HarpDeviceTypeTestSuite","text":"<pre><code>HarpDeviceTypeTestSuite(harp_device: HarpDevice)\n</code></pre> <p>               Bases: <code>Suite</code>, <code>ABC</code></p> <p>Base test suite for specific types of HARP devices.</p> <p>Abstract base class providing common functionality for testing specific HARP device types with known WhoAmI identifiers.</p> <p>Attributes:</p> Name Type Description <code>harp_device</code> <p>The HARP device to test.</p> <code>_WHOAMI</code> <code>int</code> <p>Class variable defining the expected WhoAmI value for this device type.</p> <p>Initialize the device type test suite.</p> <p>Parameters:</p> Name Type Description Default <code>harp_device</code> <code>HarpDevice</code> <p>The HARP device to test.</p> required Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def __init__(self, harp_device: HarpDevice):\n    \"\"\"Initialize the device type test suite.\n\n    Args:\n        harp_device: The HARP device to test.\n    \"\"\"\n    self.harp_device = harp_device\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.whoami","title":"whoami  <code>property</code>","text":"<pre><code>whoami: int\n</code></pre> <p>Get the expected WhoAmI value for this device type.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expected WhoAmI identifier.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.test_whoami","title":"test_whoami","text":"<pre><code>test_whoami()\n</code></pre> <p>Check if the WhoAmI value is correct</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_whoami(self):\n    \"\"\"Check if the WhoAmI value is correct\"\"\"\n    try:\n        who_am_i = self.harp_device[\"WhoAmI\"].data[\"WhoAmI\"].iloc[-1]\n    except KeyError:\n        return self.fail_test(None, \"WhoAmI data stream is not present\")\n    if who_am_i != self.whoami:\n        return self.fail_test(False, f\"Expected WhoAmI value {self.whoami} but got {who_am_i}\")\n    return self.pass_test(True, f\"WhoAmI value is {who_am_i} as expected\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpDeviceTypeTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite","title":"HarpSniffDetectorTestSuite","text":"<pre><code>HarpSniffDetectorTestSuite(\n    harp_device: HarpDevice,\n    quantization_ratio_thr: float = 0.1,\n    clustering_thr: float = 0.05,\n    clipping_thr: float = 0.05,\n    sudden_jumps_thr: float = 0.001,\n    notch_filter_freq: float = 50,\n)\n</code></pre> <p>               Bases: <code>HarpDeviceTypeTestSuite</code></p> <p>Test suite for HARP Sniff Detector devices.</p> <p>Provides tests specific to the Sniff Detector device, including signal quality analysis and breathing rate detection.</p> <p>Attributes:</p> Name Type Description <code>harp_device</code> <p>The HARP Sniff Detector device to test.</p> <code>data</code> <code>DataFrame</code> <p>The raw voltage data from the device.</p> <code>fs</code> <code>float</code> <p>The sampling frequency of the device.</p> <code>quantization_ratio_thr</code> <p>Threshold for the quantization ratio test.</p> <code>clustering_thr</code> <p>Threshold for the clustering ratio test.</p> <code>clipping_thr</code> <p>Threshold for the clipping detection test.</p> <code>sudden_jumps_thr</code> <p>Threshold for the sudden jumps detection test.</p> <code>notch_filter_freq</code> <p>Frequency (Hz) for the notch filter.</p> <p>Examples:</p> <pre><code>from contraqctor.contract.harp import HarpDevice\nfrom contraqctor.qc.harp import HarpSniffDetectorTestSuite\nfrom contraqctor.qc.base import Runner\n\n# Create and load the sniff detector device\ndevice = HarpDevice(\"sniff\", reader_params=params).load()\n\n# Create the test suite with custom thresholds\nsuite = HarpSniffDetectorTestSuite(\n    device,\n    quantization_ratio_thr=0.1,\n    clustering_thr=0.05,\n    notch_filter_freq=60  # For 60Hz power\n)\n\n# Run tests\nrunner = Runner().add_suite(suite)\nresults = runner.run_all_with_progress()\n</code></pre> <p>Initialize the Sniff Detector test suite.</p> <p>Parameters:</p> Name Type Description Default <code>harp_device</code> <code>HarpDevice</code> <p>The HARP Sniff Detector device to test.</p> required <code>quantization_ratio_thr</code> <code>float</code> <p>Threshold for the quantization ratio test. Defaults to 0.1.</p> <code>0.1</code> <code>clustering_thr</code> <code>float</code> <p>Threshold for the clustering ratio test. Defaults to 0.05.</p> <code>0.05</code> <code>clipping_thr</code> <code>float</code> <p>Threshold for the clipping detection test. Defaults to 0.05.</p> <code>0.05</code> <code>sudden_jumps_thr</code> <code>float</code> <p>Threshold for the sudden jumps detection test. Defaults to 0.001.</p> <code>0.001</code> <code>notch_filter_freq</code> <code>float</code> <p>Frequency (Hz) for the notch filter. Defaults to 50.</p> <code>50</code> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>@override\ndef __init__(\n    self,\n    harp_device: HarpDevice,\n    quantization_ratio_thr: float = 0.1,\n    clustering_thr: float = 0.05,\n    clipping_thr: float = 0.05,\n    sudden_jumps_thr: float = 0.001,\n    notch_filter_freq: float = 50,\n):\n    \"\"\"Initialize the Sniff Detector test suite.\n\n    Args:\n        harp_device: The HARP Sniff Detector device to test.\n        quantization_ratio_thr: Threshold for the quantization ratio test. Defaults to 0.1.\n        clustering_thr: Threshold for the clustering ratio test. Defaults to 0.05.\n        clipping_thr: Threshold for the clipping detection test. Defaults to 0.05.\n        sudden_jumps_thr: Threshold for the sudden jumps detection test. Defaults to 0.001.\n        notch_filter_freq: Frequency (Hz) for the notch filter. Defaults to 50.\n    \"\"\"\n    super().__init__(harp_device)\n    self.harp_device = harp_device\n    self.data: pd.DataFrame = self.harp_device[\"RawVoltage\"].data\n    self.data = self.data[self.data[\"MessageType\"] == \"EVENT\"][\"RawVoltage\"]\n    self.fs: float = self.harp_device[\"RawVoltageDispatchRate\"].data.iloc[-1].values[0]\n    self.quantization_ratio_thr = quantization_ratio_thr\n    self.clustering_thr = clustering_thr\n    self.clipping_thr = clipping_thr\n    self.sudden_jumps_thr = sudden_jumps_thr\n    self.notch_filter_freq = notch_filter_freq\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Get the description of the test suite from its docstring.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the class, or None if not available.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the test suite.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the test suite class.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.whoami","title":"whoami  <code>property</code>","text":"<pre><code>whoami: int\n</code></pre> <p>Get the expected WhoAmI value for this device type.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expected WhoAmI identifier.</p>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.test_sniff_detector_sampling_rate","title":"test_sniff_detector_sampling_rate","text":"<pre><code>test_sniff_detector_sampling_rate()\n</code></pre> <p>Tests if the sampling rate of the sniff detector is within nominal values</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_sniff_detector_sampling_rate(self):\n    \"\"\"Tests if the sampling rate of the sniff detector is within nominal values\"\"\"\n    period = self.data.index.diff().dropna()\n    mean_period = np.mean(period)\n    if abs((dfps := (1.0 / mean_period)) - self.fs) &gt; 0.1:\n        return self.fail_test(\n            dfps,\n            f\"Sampling rate is not within nominal values. Expected {self.fs} Hz but got {1.0 / mean_period:.2f} Hz\",\n        )\n    return self.pass_test(dfps, f\"Sampling rate is {dfps:.2f} Hz. Expected {self.fs} Hz\")\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.test_sniff_detector_signal_quality","title":"test_sniff_detector_signal_quality","text":"<pre><code>test_sniff_detector_signal_quality()\n</code></pre> <p>Tests the quality of the sniff detector signal by analyzing quantization, clustering, clipping, and sudden jumps.</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_sniff_detector_signal_quality(self):\n    \"\"\"Tests the quality of the sniff detector signal by analyzing quantization, clustering, clipping, and sudden jumps.\"\"\"\n    metrics = {}\n    TOTAL_SAMPLES = len(self.data)\n\n    metrics[\"quantization_ratio\"] = len(np.unique(self.data.values)) / self._FULL_BIT_DEPTH\n\n    hist, _ = np.histogram(self.data.values, bins=self._FULL_BIT_DEPTH)\n    metrics[\"clustering_ratio\"] = np.max(hist) / TOTAL_SAMPLES\n\n    # Check for clipping:\n    tol = (np.max(self.data) - np.min(self.data)) * 0.01\n\n    metrics[\"min_clipping\"] = np.sum(np.abs(self.data - np.min(self.data)) &lt; tol) / TOTAL_SAMPLES\n    metrics[\"max_clipping\"] = np.sum(np.abs(self.data - np.max(self.data)) &lt; tol) / TOTAL_SAMPLES\n\n    # Check for weird discontinuities\n    derivative = np.diff(self.data.values) / np.diff(self.data.index)\n    sudden_jumps_ratio = (np.sum(np.abs(derivative) &gt; 3 * np.std(derivative))) / TOTAL_SAMPLES\n    metrics[\"sudden_jumps_ratio\"] = sudden_jumps_ratio\n\n    is_ok = (\n        metrics[\"quantization_ratio\"] &gt; self.quantization_ratio_thr\n        and metrics[\"clustering_ratio\"] &lt; self.clustering_thr\n        and metrics[\"min_clipping\"] &lt; self.clipping_thr\n        and metrics[\"max_clipping\"] &lt; self.clipping_thr\n        and metrics[\"sudden_jumps_ratio\"] &lt; self.sudden_jumps_thr\n    )\n\n    if is_ok:\n        return self.pass_test(True, \"Signal quality is good\", context=metrics)\n    else:\n        return self.fail_test(\n            False,\n            \"Signal quality is not good\",\n            context=metrics,\n        )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.test_sniff_detector_physiology","title":"test_sniff_detector_physiology","text":"<pre><code>test_sniff_detector_physiology()\n</code></pre> <p>Tests if the sniff detector is actually detecting sniffs by analyzing peaks in the signal.</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_sniff_detector_physiology(self):\n    \"\"\"Tests if the sniff detector is actually detecting sniffs by analyzing peaks in the signal.\"\"\"\n\n    t = self.data.index.values\n    signal = self.data.values\n    dt = 1.0 / self.fs\n    t_uniform = np.arange(t[0], t[-1], dt)\n\n    interp_func = interp1d(t, signal, kind=\"linear\", bounds_error=False, fill_value=\"extrapolate\")\n    y_uniform = interp_func(t_uniform)\n\n    Q = 30.0\n    b_notch, a_notch = iirnotch(self.notch_filter_freq, Q, self.fs)\n    y_notch = filtfilt(b_notch, a_notch, y_uniform)\n\n    b_high, a_high = butter(2, 0.2, \"highpass\", fs=self.fs)\n    y_filtered = filtfilt(b_high, a_high, y_notch)\n\n    b_low, a_low = butter(2, 15, \"lowpass\", fs=self.fs)\n    y_filtered = filtfilt(b_low, a_low, y_filtered)\n\n    peaks, _ = find_peaks(y_filtered, height=0.5 * np.std(y_filtered), prominence=2.5)\n\n    # Create the asset and pass it in the context\n    fig, axes = plt.subplots(2, 1, figsize=(10, 8))\n\n    axes[0].plot(t_uniform, y_uniform, \"b-\")\n    axes[0].plot(t_uniform[peaks], y_uniform[peaks], \"ro\")\n    axes[0].set_title(\"Filtered Breathing Signal with Detected Peaks\")\n    axes[0].set_xlabel(\"Time (s)\")\n    axes[0].set_ylabel(\"Amplitude\")\n    middle_time = (t_uniform[0] + t_uniform[-1]) / 2\n    axes[0].set_xlim(middle_time - 30 / 2, middle_time + 30 / 2)\n\n    if len(peaks) &gt;= 2:\n        ipi = np.diff(peaks) * dt\n        breathing_rate = 1.0 / np.mean(ipi)\n        metrics = {\n            \"num_peaks\": len(peaks),\n            \"mean_ipi\": np.mean(ipi),\n            \"std_ipi\": np.std(ipi),\n            \"breathing_rate_hz\": breathing_rate,\n            \"perc99\": 1.0 / np.percentile(ipi, 0.99),\n            \"perc01\": 1.0 / np.percentile(ipi, 0.01),\n        }\n\n        axes[1].hist(ipi, bins=np.arange(0, 1, 0.025), alpha=0.7)\n        axes[1].axvline(\n            np.mean(ipi),\n            color=\"r\",\n            linestyle=\"--\",\n            label=f\"Mean: {np.mean(ipi):.3f}s ({breathing_rate * 60:.1f} BPM)\",\n        )\n        axes[1].set_title(\"Histogram of Inter-Peak Intervals\")\n        axes[1].set_xlabel(\"Interval (s)\")\n        axes[1].set_ylabel(\"Count\")\n        axes[1].legend()\n\n        fig.tight_layout()\n\n        context = ContextExportableObj.as_context(fig)\n        context.update(metrics)\n        min_max_breathing_rate = (2, 10)  # in Hz\n        if min_max_breathing_rate[0] &lt;= breathing_rate &lt;= min_max_breathing_rate[1]:\n            return self.pass_test(metrics, f\"Breathing rate is {breathing_rate} Hz\", context=context)\n        else:\n            return self.warn_test(\n                metrics,\n                f\"Breathing rate is {breathing_rate} Hz. Expected between {min_max_breathing_rate[0]} and {min_max_breathing_rate[1]} Hz\",\n                context=context,\n            )\n\n    else:\n        return self.fail_test(\n            {\"num_peaks\": len(peaks)}, \"Failed to detect sufficient peaks in the breathing signal\", context=context\n        )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; Generator[ITest, None, None]\n</code></pre> <p>Find all methods starting with 'test'.</p> <p>Yields:</p> Name Type Description <code>ITest</code> <code>ITest</code> <p>Test methods found in the suite.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def get_tests(self) -&gt; t.Generator[ITest, None, None]:\n    \"\"\"Find all methods starting with 'test'.\n\n    Yields:\n        ITest: Test methods found in the suite.\n    \"\"\"\n    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):\n        if name.startswith(\"test\"):\n            yield method\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.pass_test","title":"pass_test","text":"<pre><code>pass_test() -&gt; Result\n</code></pre><pre><code>pass_test(result: Any) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>pass_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>pass_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>pass_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a passing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test passed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with PASSED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def pass_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a passing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test passed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with PASSED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.PASSED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.warn_test","title":"warn_test","text":"<pre><code>warn_test() -&gt; Result\n</code></pre><pre><code>warn_test(result: Any) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>warn_test(result: Any, *, context: Any) -&gt; Result\n</code></pre><pre><code>warn_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>warn_test(\n    result: Any = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a warning test result.</p> <p>Creates a result with WARNING status, or FAILED if warnings are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing the warning.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with WARNING or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def warn_test(\n    self, result: t.Any = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a warning test result.\n\n    Creates a result with WARNING status, or FAILED if warnings are elevated.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing the warning.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with WARNING or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.WARNING if not _elevate_warning.get() else Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.fail_test","title":"fail_test","text":"<pre><code>fail_test() -&gt; Result\n</code></pre><pre><code>fail_test(result: Any) -&gt; Result\n</code></pre><pre><code>fail_test(result: Any, message: str) -&gt; Result\n</code></pre><pre><code>fail_test(\n    result: Any, message: str, *, context: Any\n) -&gt; Result\n</code></pre> <pre><code>fail_test(\n    result: Optional[Any] = None,\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a failing test result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Optional[Any]</code> <p>The value to include in the test result.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Optional message describing why the test failed.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def fail_test(\n    self, result: t.Optional[t.Any] = None, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None\n) -&gt; Result:\n    \"\"\"Create a failing test result.\n\n    Args:\n        result: The value to include in the test result.\n        message: Optional message describing why the test failed.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n\n    return Result(\n        status=Status.FAILED,\n        result=result,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.skip_test","title":"skip_test","text":"<pre><code>skip_test() -&gt; Result\n</code></pre><pre><code>skip_test(message: str) -&gt; Result\n</code></pre><pre><code>skip_test(message: str, *, context: Any) -&gt; Result\n</code></pre> <pre><code>skip_test(\n    message: Optional[str] = None,\n    *,\n    context: Optional[Any] = None,\n) -&gt; Result\n</code></pre> <p>Create a skipped test result.</p> <p>Creates a result with SKIPPED status, or FAILED if skips are elevated.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>Optional message explaining why the test was skipped.</p> <code>None</code> <code>context</code> <code>Optional[Any]</code> <p>Optional contextual data for the test result.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>A Result object with SKIPPED or FAILED status.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def skip_test(self, message: t.Optional[str] = None, *, context: t.Optional[t.Any] = None) -&gt; Result:\n    \"\"\"Create a skipped test result.\n\n    Creates a result with SKIPPED status, or FAILED if skips are elevated.\n\n    Args:\n        message: Optional message explaining why the test was skipped.\n        context: Optional contextual data for the test result.\n\n    Returns:\n        Result: A Result object with SKIPPED or FAILED status.\n    \"\"\"\n    calling_func_name, description = self._get_caller_info()\n    return Result(\n        status=Status.SKIPPED if not _elevate_skippable.get() else Status.FAILED,\n        result=None,\n        test_name=calling_func_name,\n        suite_name=self.name,\n        message=message,\n        context=context,\n        description=description,\n    )\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Run before each test method.</p> <p>This method can be overridden by subclasses to implement setup logic that runs before each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Run before each test method.\n\n    This method can be overridden by subclasses to implement\n    setup logic that runs before each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Run after each test method.</p> <p>This method can be overridden by subclasses to implement teardown logic that runs after each test.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Run after each test method.\n\n    This method can be overridden by subclasses to implement\n    teardown logic that runs after each test.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.run_test","title":"run_test","text":"<pre><code>run_test(\n    test_method: ITest,\n) -&gt; Generator[Result, None, None]\n</code></pre> <p>Run a single test method and yield its results.</p> <p>Handles setup, test execution, result processing, and teardown.</p> <p>Parameters:</p> Name Type Description Default <code>test_method</code> <code>ITest</code> <p>The test method to run.</p> required <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by the test method.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_test(self, test_method: ITest) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run a single test method and yield its results.\n\n    Handles setup, test execution, result processing, and teardown.\n\n    Args:\n        test_method: The test method to run.\n\n    Yields:\n        Result: Result objects produced by the test method.\n    \"\"\"\n    test_name = test_method.__name__\n    suite_name = self.name\n    test_description = getattr(test_method, \"__doc__\", None)\n\n    try:\n        self.setup()\n        result = test_method()\n        if inspect.isgenerator(result):\n            for sub_result in result:\n                yield self._process_test_result(sub_result, test_method, test_name, test_description)\n        else:\n            yield self._process_test_result(result, test_method, test_name, test_description)\n    except Exception as e:\n        tb = traceback.format_exc()\n        yield Result(\n            status=Status.ERROR,\n            result=None,\n            test_name=test_name,\n            suite_name=suite_name,\n            description=test_description,\n            message=f\"Error during test execution: {str(e)}\",\n            exception=e,\n            traceback=tb,\n            test_reference=test_method,\n            suite_reference=self,\n        )\n    finally:\n        self.teardown()\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.run_all","title":"run_all","text":"<pre><code>run_all() -&gt; Generator[Result, None, None]\n</code></pre> <p>Run all test methods in the suite.</p> <p>Finds all test methods and runs them in sequence.</p> <p>Yields:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result objects produced by all test methods.</p> Source code in <code>src/contraqctor/qc/base.py</code> <pre><code>def run_all(self) -&gt; t.Generator[Result, None, None]:\n    \"\"\"Run all test methods in the suite.\n\n    Finds all test methods and runs them in sequence.\n\n    Yields:\n        Result: Result objects produced by all test methods.\n    \"\"\"\n    for test in self.get_tests():\n        yield from self.run_test(test)\n</code></pre>"},{"location":"api/qc/harp/#contraqctor.qc.harp.HarpSniffDetectorTestSuite.test_whoami","title":"test_whoami","text":"<pre><code>test_whoami()\n</code></pre> <p>Check if the WhoAmI value is correct</p> Source code in <code>src/contraqctor/qc/harp.py</code> <pre><code>def test_whoami(self):\n    \"\"\"Check if the WhoAmI value is correct\"\"\"\n    try:\n        who_am_i = self.harp_device[\"WhoAmI\"].data[\"WhoAmI\"].iloc[-1]\n    except KeyError:\n        return self.fail_test(None, \"WhoAmI data stream is not present\")\n    if who_am_i != self.whoami:\n        return self.fail_test(False, f\"Expected WhoAmI value {self.whoami} but got {who_am_i}\")\n    return self.pass_test(True, f\"WhoAmI value is {who_am_i} as expected\")\n</code></pre>"},{"location":"doc_examples/contract/","title":"Contract Examples","text":"<p>This page demonstrates how to use the Contract module.</p>"},{"location":"doc_examples/contract/#example-code","title":"Example Code","text":"<p>The following example shows how to work with data streams and contracts:</p> <pre><code>from pathlib import Path\n\nfrom aind_behavior_services.rig import AindBehaviorRigModel\nfrom aind_behavior_services.session import AindBehaviorSessionModel\nfrom aind_behavior_services.task_logic import AindBehaviorTaskLogicModel\n\nfrom contraqctor.contract import Dataset, DataStreamCollection\nfrom contraqctor.contract.camera import Camera\nfrom contraqctor.contract.csv import Csv\nfrom contraqctor.contract.harp import (\n    DeviceYmlByFile,\n    HarpDevice,\n)\nfrom contraqctor.contract.json import PydanticModel, SoftwareEvents\nfrom contraqctor.contract.mux import MapFromPaths\nfrom contraqctor.contract.text import Text\nfrom contraqctor.contract.utils import print_data_stream_tree\n\ndataset_root = Path(r\"path_to_data\")\nmy_dataset = Dataset(\n    name=\"my_dataset\",\n    version=\"1.0.0\",\n    description=\"My dataset\",\n    data_streams=[\n        MapFromPaths(\n            name=\"BehaviorVideos\",\n            description=\"Data from BehaviorVideos modality\",\n            reader_params=MapFromPaths.make_params(\n                paths=dataset_root / \"behavior-videos\",\n                include_glob_pattern=[\"*\"],\n                inner_data_stream=Camera,\n                inner_param_factory=lambda x: Camera.make_params(path=dataset_root / \"behavior-videos\" / x),\n            ),\n        ),\n        DataStreamCollection(\n            name=\"Behavior\",\n            description=\"Data from the Behavior modality\",\n            data_streams=[\n                HarpDevice(\n                    name=\"HarpBehavior\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/Behavior.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpManipulator\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/StepperDriver.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpTreadmill\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/Treadmill.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpOlfactometer\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/Olfactometer.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpSniffDetector\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/SniffDetector.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpLickometer\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/Lickometer.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpClockGenerator\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/ClockGenerator.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                HarpDevice(\n                    name=\"HarpEnvironmentSensor\",\n                    reader_params=HarpDevice.make_params(\n                        path=dataset_root / \"behavior/EnvironmentSensor.harp\",\n                        device_yml_hint=DeviceYmlByFile(),\n                    ),\n                ),\n                DataStreamCollection(\n                    name=\"HarpCommands\",\n                    description=\"Commands sent to Harp devices\",\n                    data_streams=[\n                        HarpDevice(\n                            name=\"HarpBehavior\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/Behavior.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpManipulator\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/StepperDriver.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpTreadmill\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/Treadmill.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpOlfactometer\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/Olfactometer.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpSniffDetector\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/SniffDetector.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpLickometer\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/Lickometer.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpClockGenerator\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/ClockGenerator.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                        HarpDevice(\n                            name=\"HarpEnvironmentSensor\",\n                            reader_params=HarpDevice.make_params(\n                                path=dataset_root / \"behavior/HarpCommands/EnvironmentSensor.harp\",\n                                device_yml_hint=DeviceYmlByFile(),\n                            ),\n                        ),\n                    ],\n                ),\n                DataStreamCollection(\n                    name=\"SoftwareEvents\",\n                    description=\"Software events generated by the workflow. The timestamps of these events are low precision and should not be used to align to physiology data.\",\n                    data_streams=[\n                        SoftwareEvents(\n                            name=\"ActivePatch\",\n                            description=\"An event emitted when a patch threshold is crossed.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/ActivePatch.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"ActiveSite\",\n                            description=\"An event emitted when a site becomes active.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/ActiveSite.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"ArmOdor\",\n                            description=\"An event sent each time an Odor mixture messaged is sent to arm at the olfactometer.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/ArmOdor.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"Block\",\n                            description=\"An event signaling block transitions.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/Block.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"ChoiceFeedback\",\n                            description=\"A unit event that is emitted when the subject receives feedback about their choice.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/ChoiceFeedback.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"DepletionVariable\",\n                            description=\"The value of the variable used to determine the depletion state of the current patch.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/DepletionVariable.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"GiveReward\",\n                            description=\"The amount of rward given to a subject. The value can be null if no reward was given (P=0) or 0.0 if the reward was delivered but calculated to be 0.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/GiveReward.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"PatchRewardAmount\",\n                            description=\"Amount of reward available to be collected in the upcoming site.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/PatchRewardAmount.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"PatchRewardAvailable\",\n                            description=\"Amount of reward left in the patch.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/PatchRewardAvailable.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"PatchRewardProbability\",\n                            description=\"Probability of reward being available to be collected in the upcoming site.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/PatchRewardProbability.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"RngSeed\",\n                            description=\"The value of the random number generator seed.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/RngSeed.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"StopVelocityThreshold\",\n                            description=\"The velocity threshold used to determine if the subject is stopped or not. In cm/s.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/StopVelocityTreshold.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"VisualCorridorSpecs\",\n                            description=\"Specification of the visual corridor instantiated to be rendered.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/VisualCorridorSpecs.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"WaitRewardOutcome\",\n                            description=\"The outcome of the period between choice and reward delivery.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/WaitRewardOutcome.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"WaitLickOutcome\",\n                            description=\"The outcome of the period between reward availability and lick detection.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/WaitLickOutcome.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"UpdaterStopDurationOffset\",\n                            description=\"Metadata for the updater of the StopDurationOffset parameter.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/UpdaterStopDurationOffset.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"UpdaterStopVelocityThreshold\",\n                            description=\"Metadata for the updater of the StopVelocityThreshold parameter.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/UpdaterStopVelocityThreshold.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"UpdaterRewardDelayOffset\",\n                            description=\"Metadata for the updater of the RewardDelayOffset parameter.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/UpdaterRewardDelayOffset.json\"\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"HabituationRewardAvailable\",\n                            description=\"In the habituation task mode, this event will be emitted whenever a reward is available to be collected.\",\n                            reader_params=SoftwareEvents.make_params(\n                                dataset_root / \"behavior/SoftwareEvents/HabituationRewardAvailable.json\"\n                            ),\n                        ),\n                    ],\n                ),\n                Csv(\n                    \"CurrentPosition\",\n                    description=\"The position of the animal in VR coordinates (cm). The timestamp is derived from the encoder reading that gave rise to the position change.\",\n                    reader_params=Csv.make_params(\n                        path=dataset_root / \"behavior/OperationControl/CurrentPosition.csv\",\n                    ),\n                ),\n                Csv(\n                    \"IsStopped\",\n                    description=\"The result of the ongoing stop detection algorithm. The timestamp is derived from the encoder reading that gave rise to the position change.\",\n                    reader_params=Csv.make_params(\n                        path=dataset_root / \"behavior/OperationControl/IsStopped.csv\",\n                    ),\n                ),\n                Csv(\n                    \"Torque\",\n                    description=\"The torque instructed to be applied to the treadmill. Timestamps are software-derived, use the Harp device events for hardware timestamps.\",\n                    reader_params=Csv.make_params(\n                        path=dataset_root / \"behavior/OperationControl/CurrentPosition.csv\",\n                    ),\n                ),\n                Csv(\n                    name=\"RendererSynchState\",\n                    description=\"Contains information that allows the post-hoc alignment of visual stimuli to the behavior data.\",\n                    reader_params=Csv.make_params(path=dataset_root / \"behavior/Renderer/RendererSynchState.csv\"),\n                ),\n                DataStreamCollection(\n                    name=\"Logs\",\n                    data_streams=[\n                        Text(\n                            name=\"Launcher\",\n                            description=\"Contains the console log of the launcher process.\",\n                            reader_params=Text.make_params(\n                                path=dataset_root / \"behavior/Logs/launcher.log\",\n                            ),\n                        ),\n                        SoftwareEvents(\n                            name=\"EndSession\",\n                            description=\"A file that determines the end of the session. If the file is empty, the session is still running or it was not closed properly.\",\n                            reader_params=SoftwareEvents.make_params(\n                                path=dataset_root / \"behavior/Logs/EndSession.json\",\n                            ),\n                        ),\n                    ],\n                ),\n                DataStreamCollection(\n                    name=\"InputSchemas\",\n                    description=\"Configuration files for the behavior rig, task_logic and session.\",\n                    data_streams=[\n                        PydanticModel(\n                            name=\"Rig\",\n                            reader_params=PydanticModel.make_params(\n                                model=AindBehaviorRigModel,\n                                path=dataset_root / \"behavior/Logs/rig_input.json\",\n                            ),\n                        ),\n                        PydanticModel(\n                            name=\"TaskLogic\",\n                            reader_params=PydanticModel.make_params(\n                                model=AindBehaviorTaskLogicModel,\n                                path=dataset_root / \"behavior/Logs/tasklogic_input.json\",\n                            ),\n                        ),\n                        PydanticModel(\n                            name=\"Session\",\n                            reader_params=PydanticModel.make_params(\n                                model=AindBehaviorSessionModel,\n                                path=dataset_root / \"behavior/Logs/session_input.json\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n        ),\n    ],\n)\n\n\nif __name__ == \"__main__\":\n    print(my_dataset.at(\"Behavior\").at(\"HarpManipulator\").load().at(\"WhoAmI\").load().data)\n    len([x for x in my_dataset if ((not x.is_collection) and isinstance(x, SoftwareEvents))])\n\n    exc = my_dataset.load_all()\n\n    for e in exc if exc is not None else []:\n        print(f\"Stream: {e[0]}\")\n        print(f\"Exception: {e[1]}\")\n        print()\n\n    print(my_dataset.at(\"Behavior\").at(\"HarpBehavior\").at(\"WhoAmI\").read())\n\n    print(my_dataset.at(\"Behavior\").at(\"HarpCommands\").at(\"HarpBehavior\").at(\"OutputSet\").read())\n    print(my_dataset.at(\"Behavior\").at(\"SoftwareEvents\"))\n    print(my_dataset.at(\"Behavior\").at(\"SoftwareEvents\").at(\"DepletionVariable\").read())\n    print(my_dataset.at(\"Behavior\").at(\"SoftwareEvents\").at(\"DepletionVariable\"))\n\n    print(my_dataset.at(\"Behavior\").at(\"IsStopped\").data)\n    print(my_dataset.at(\"Behavior\").at(\"RendererSynchState\").data)\n\n    print(my_dataset[\"Behavior\"][\"InputSchemas\"][\"Session\"].data)\n\n    path = \"\"\n    child = my_dataset.at(\"Behavior\").at(\"SoftwareEvents\").at(\"DepletionVariable\")\n    while child.parent is not None:\n        path = f\"{child.name}:{path}\"\n        child = child.parent\n    print(path)\n\n    print(my_dataset.at(\"Behavior\").at(\"HarpBehavior\").device_reader)\n\n    with open(\"my_dataset.md\", \"w\", encoding=\"UTF-8\") as f:\n        f.write(print_data_stream_tree(my_dataset))\n\n    print(my_dataset.at(\"Behavior\").at(\"HarpBehavior\").resolved_name)\n</code></pre>"},{"location":"doc_examples/qc/","title":"Quality Control Examples","text":"<p>This page demonstrates how to use the Quality Control (qc) module.</p>"},{"location":"doc_examples/qc/#example-code","title":"Example Code","text":"<p>The following example shows how to create and run quality control tests:</p> <pre><code>from contract import my_dataset\n\nimport contraqctor.qc as qc\nfrom contraqctor.contract.csv import Csv\nfrom contraqctor.contract.harp import HarpDevice\n\nharp_behavior: HarpDevice = my_dataset[\"Behavior\"][\"HarpBehavior\"]\nharp_sniff_detector: HarpDevice = my_dataset[\"Behavior\"][\"HarpSniffDetector\"]\nharp_behavior.load_all()\nharp_sniff_detector.load_all()\n\nclock_generator: HarpDevice = my_dataset[\"Behavior\"][\"HarpClockGenerator\"]\nclock_generator.load_all()\nclock_generator_commands: HarpDevice = my_dataset[\"Behavior\"][\"HarpCommands\"][\"HarpClockGenerator\"]\nerr = clock_generator_commands.load_all()\n\nharp_behavior_commands: HarpDevice = my_dataset[\"Behavior\"][\"HarpCommands\"][\"HarpBehavior\"]\nharp_sniff_detector_commands: HarpDevice = my_dataset[\"Behavior\"][\"HarpCommands\"][\"HarpSniffDetector\"]\n\nis_stopped: Csv = my_dataset[\"Behavior\"][\"IsStopped\"]\nis_stopped.load_all()\nharp_behavior_commands.load_all()\nerr3 = harp_sniff_detector_commands.load_all()\n\ncamera_test = my_dataset[\"BehaviorVideos\"]\nerr2 = camera_test.load_all()\n\nwith qc.elevated_skips(False):\n    runner = qc.Runner()\n    runner.add_suite(qc.harp.HarpDeviceTestSuite(harp_behavior, harp_behavior_commands))\n    runner.add_suite(qc.harp.HarpDeviceTestSuite(harp_sniff_detector, harp_sniff_detector_commands))\n    runner.add_suite(qc.harp.HarpDeviceTestSuite(clock_generator, clock_generator_commands))\n    runner.add_suite(qc.csv.CsvTestSuite(is_stopped))\n    runner.add_suite(qc.harp.HarpHubTestSuite(clock_generator, [harp_behavior, harp_sniff_detector]))\n    runner.add_suite(qc.harp.HarpSniffDetectorTestSuite(harp_sniff_detector))\n    runner.add_suite(qc.camera.CameraTestSuite(camera_test[\"FaceCamera\"]))\n    runner.add_suite(qc.contract.ContractTestSuite(err + err2 + err3, exclude=[s for s, _ in err]))\n    results = runner.run_all_with_progress(render_context=False)\n</code></pre>"}]}